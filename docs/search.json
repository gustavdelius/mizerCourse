[
  {
    "objectID": "understand/species-interactions.html",
    "href": "understand/species-interactions.html",
    "title": "Species interactions",
    "section": "",
    "text": "In the previous tutorials we studied a single species interacting with a fixed background community. In this tutorial we want to acknowledge that there is no such thing as a fixed background community. Instead, all species form part of a dynamical ecosystem in which changes to any species has knock-on effects on other species. Furthermore, the resulting changes in the other species will react back on the first species, which now finds its prey community and its predator community changed. This is where we realise that we need multi-species models, because without such a model we cannot predict how all these changes will affect each other.\nlibrary(mizer)\nlibrary(mizerExperimental)\nlibrary(tidyverse)"
  },
  {
    "objectID": "understand/species-interactions.html#trait-based-model",
    "href": "understand/species-interactions.html#trait-based-model",
    "title": "Species interactions",
    "section": "Trait-based model",
    "text": "Trait-based model\nIn this first week we aim for understanding, not realism. So in this tutorial we investigate the tangled web of interactions in an idealised multi-species system. We choose a trait-based model in which the species making up the community differ from each other only in a single trait: their asymptotic body size (sometimes it is also called maximum body size).\nWe use the newTraitParams() function to create our idealised trait-based multi-species model. The function has many parameters, but we will just keep the defaults. Unlike the newSingleSpeciesParams() function, the newTraitParams() function does not set the initial spectra to their steady state values. We thus need to run the result through the steady() function (we’ll discuss that function more next week). We assign the resulting MizerParams object to the variable mp.\n\nmp &lt;- newTraitParams() |&gt; steady()\n\nLet us look at the biomass density in log weight.\n\nplotSpectra(mp, power = 2, total = TRUE)\n\n\n\n\nWe see 11 species spectra and a resource spectrum. The resource spectrum starts at a smaller size than the fish spectra, in order to provide food also for the smallest individuals (larvae) of the fish spectra. Each species spectrum has a shape of the type we expect, given what we have seen in the tutorial on single species spectra. The spectra of the different species all look essentially the same, except for being shifted along the size axis. This is because in this trait-based model the species differ only through their asymptotic size. This regularity will of course not be present in a real-world ecosystem, but it makes it easier for us to build an intuition about the effects of species interactions.\nNote how the community size spectrum, plotted in black, that is obtained by summing together all the individual species and resource spectra, approximately follows a power law (i.e., approximately follows a straight line in the log-log plot).\nTurn off reproduction dynamics\nAs in previous tutorials, we want to concentrate on the shapes of the size spectra and we do not yet want to look at what determines the overall abundance of each species. Therefore we modify the model so that it keeps the abundances at egg size fixed (i.e. numbers in the first size bin). You do not need to look in detail at the following code, except to note that a mizer model is very customisable in the sense that an advanced user can overwrite almost any behaviour with custom behaviour.\n\nmp &lt;- mp |&gt;\n    setRateFunction(\"RDI\", \"constantEggRDI\") |&gt;\n    setRateFunction(\"RDD\", \"noRDD\")\n\nThe functionality for customising and extending mizer will be the subject of an entire extra part of this course. But in the meantime you can certainly let us know what kinds of customisation you would like to make in the comments section and we can give pointers. You can also look at a recent blog post where Phoebe Woodworth-Jefcoats shows how to use custom rate functions to implement temperature-dependent rates in mizer."
  },
  {
    "objectID": "understand/species-interactions.html#mortality-from-other-species",
    "href": "understand/species-interactions.html#mortality-from-other-species",
    "title": "Species interactions",
    "section": "Mortality from other species",
    "text": "Mortality from other species\nThe species interact with each other via predator-prey interactions. These interactions shape both mortality and energy income. In this section we look at mortality imposed on a particular species by its predators. We choose to look at species 8. The following graph shows the relative contributions to the mortality rate for species 8 from all the other species:\n\nplotlyDeath(mp, species = \"8\")\n\n\n\n\n\nThe horizontal axis shows the size of the individual whose mortality we are looking at. Towards the left we see the mortality of the small larvae, as we move towards the right we move to larger individuals. So the main important message from this graph is that as an individual grows up their main predators change.\nYou might have expected that species 8 would be predated upon by the larger species 9, 10 and 11. And for large individuals of species 8, these three species do indeed form the dominant source of predation mortality, but we see also that smaller individuals of species 8 are predominantly predated upon by predators from smaller species. This arises because each predator prefers to feed at a certain fraction of its own size (which is set to 1/100th in this model), so the larger predators loose interest in the larvae and concentrate on the larger prey.\nThis ontogenetic diet shift as an individual grows up is one reason why standard food-web models, where interaction between predator and prey is entirely determined by their species, are insufficient for modelling fish communities.\nIn the above graph you also see that the smallest individuals and the largest individuals get the majority of their mortality from “external” sources, by which we designate all the mortality that is not from predation by the modelled species. So it is “external” in the sense that its sources are not represented inside the model. For large individuals this external mortality would include predation from mammals and seabirds as well as senescence mortality. For small individuals this external mortality comes from predation by small, possibly planktonic, organisms that are not explicitly modelled.\nIn the absence of other information, our simple trait-based model just assumes that this external mortality is such that the total mortality scales allometrically with an individual’s size to the power of -1/4. This is why larval mortality is actually quite high. We can see this in the following plot which instead of proportions shows the actual mortality rates:\n\nplotDeath(mp, species = \"8\", proportion = FALSE)\n\n\n\n\nThe plotDeath() function is extremely useful when building your own model. It is important to know where the majority of mortality on your species and its various sizes come from."
  },
  {
    "objectID": "understand/species-interactions.html#income-from-other-species",
    "href": "understand/species-interactions.html#income-from-other-species",
    "title": "Species interactions",
    "section": "Income from other species",
    "text": "Income from other species\nNow that we have investigated who eats species 8, we also want to know who is eaten by species 8. We can check that by plotting the diet of this species:\n\nplotDiet(mp, species = \"8\")\n\n\n\n\nThe diet looks quite reasonable. Small individuals of species 8 initially feed entirely on the resource (plankton and other small things). From about the size of 1g (which is roughly 4-5 cm) they start eating also larvae of other fish.\nThe diet composition we see in the plot is shaped by two things: the predation kernel (the size preference in the feeding of the predator) and the relative abundances of prey at different sizes. First, a predator will only eat food that is within the predation kernel size range. But once in this size range the relative proportion of different species or resource consumed will simply depend on their relative biomass. So if, for example, 80% of biomass in a specific prey size class consists of resource, 15% of species 1 and 5% of species 2, then the diet of the predator feeding in that size class will consist of 80% resource, 15% of species 1 and 5% of species 2.\nIn our example model, resource abundance at small size classes is very high compared to abundance of fish. So when a predator feeds in those size classes, naturally most of the diet will consist of resource. This is what we see in the diet plot.\nOf course, when we build a model for a real-world ecosystem we will have some knowledge about the biology of the species and their food preferences. Perhaps one species is actively selecting fish out of the resource, or predating on specific species only? This is where the interaction matrix comes in that we will discuss in the next section.\nIt is very important to explore diets of species in your model, so, like the plotDeath() function, the plotDiet() function is very useful.\n\n\n\n\n\n\nExercise 1\n\n\n\n\n\nNow, check what the diets of other species look like by making a plot for each species from 1 (smallest one) to 11 (the largest one). Hint: if you look at the documentation for plotDiet() you may find a convenient way to do this.\n\n\n\n\n\n\nShow me the solution\n\n\n\n\n\n\nplotDiet(mp)"
  },
  {
    "objectID": "understand/species-interactions.html#interaction-matrix",
    "href": "understand/species-interactions.html#interaction-matrix",
    "title": "Species interactions",
    "section": "Interaction matrix",
    "text": "Interaction matrix\nNow we arrive to an interesting and challenging aspects of multi-species modelling - setting up parameters for species and resource interactions. By default, mizer assumes that all species in the model can access all other species and resource equally and the amount of different prey consumed just depends on their relative abundance in the predator’s feeding size range. So the default interaction matrix of the species in our model looks very simple\n\ninteraction_matrix(mp)\n\n        prey\npredator 1 2 3 4 5 6 7 8 9 10 11\n      1  1 1 1 1 1 1 1 1 1  1  1\n      2  1 1 1 1 1 1 1 1 1  1  1\n      3  1 1 1 1 1 1 1 1 1  1  1\n      4  1 1 1 1 1 1 1 1 1  1  1\n      5  1 1 1 1 1 1 1 1 1  1  1\n      6  1 1 1 1 1 1 1 1 1  1  1\n      7  1 1 1 1 1 1 1 1 1  1  1\n      8  1 1 1 1 1 1 1 1 1  1  1\n      9  1 1 1 1 1 1 1 1 1  1  1\n      10 1 1 1 1 1 1 1 1 1  1  1\n      11 1 1 1 1 1 1 1 1 1  1  1\n\n\nThe matrix has all values set at 1 which means that all predators can access all prey species equally.\nIn reality we might have some knowledge about predators’ diet preferences, or about prey vulnerability to predation. This knowledge should be incorporated in the interaction matrix. Perhaps we know that some predators cannot or do not eat certain prey. For example some species in our system might only feed on plankton and never ever eat any fish. In this case we will set all values in the row for that predator equal to 0. Or we might know that some prey is less available to predation due to some anti-predation behaviour or defence mechanisms. In this case we would decrease all values in the prey column to something &lt; 1.\n\n\n\n\n\n\nImportant\n\n\n\n\n\nYou should not set an entry in the interaction matrix to 0 just because a particular prey is never recorded in the stomach of a predator. It may well be that the predator species consumes the larvae of the prey species at some stage of their life and these larvae are simply not recorded in the stomach content.\n\n\n\nThe interaction matrix can encode lots of effects. Sometimes the interaction matrix is used to encode spatial overlap of species in a large ecosystem, as in this application of mizer to the North Sea. In this case the interaction matrix might be estimated from spatial surveys assessing species spatial overlap.\nLet’s go ahead and change one value in the interaction matrix.\n\nmp_modified &lt;- mp\n# We change row 11 (predator species 11) and column 2 (prey species 2) \n# to a smaller value\ninteraction_matrix(mp)[11, 2] &lt;- 0.2\n\nNow let’s compare the source of mortality for species 2 in the two models.\n\nplotDeath(mp, species = 2)\nplotDeath(mp_modified, species = 2)\n\n\n\n\n\nOriginal\n\n\n\n\n\nModified\n\n\n\n\n\nYou will see a reduction of the contribution of species 11 to the mortality of species 2.\nNext let us compare diets of species 11 in the two models.\n\nplotDiet(mp, species = 11)\nplotDiet(mp_modified, species = 11)\n\n\n\n\n\nOriginal\n\n\n\n\n\nModified\n\n\n\n\n\nYou will see a reduction in the contribution of species 2 to the diet of species 11. By setting the entry in row 11 and column 2 of the interaction matrix to 0.2 we simply reduced the availability of prey species 2 for predator species 11 by a factor of 5. The entries in the interaction matrix simply serve as multipliers on the available prey biomass.\nResource interactions\nThe interaction coefficients between the fish species as consumers and the resource as food, which one could have expected to find in an additional column in the interaction matrix, is instead saved as a species parameter.\n\nspecies_params(mp)$interaction_resource\n\n [1] 1 1 1 1 1 1 1 1 1 1 1\n\n\nWe see that the default value for all these interaction coefficients is also 1.\nNow we might want to reduce the availability of resource to some predators. Perhaps we know that certain species much prefer to feed on other fish rather than on similar sized plankton. Let us look at an example where species 8 through 11 have a 20% reduction in their interaction with resource.\n\n# We make a copy of the model\nmp_lessRes &lt;- mp\n# and set the resource interaction to 0.8 for species 8 to 11\nspecies_params(mp_lessRes)$interaction_resource[8:11] &lt;- 0.8\n# We print out the result to check\nspecies_params(mp_lessRes)$interaction_resource\n\n [1] 1.0 1.0 1.0 1.0 1.0 1.0 1.0 0.8 0.8 0.8 0.8\n\n\nNow we can look at the diet of for example species 9 and compare it with the previous model\n\nplotDiet(mp, species = 9)\nplotDiet(mp_lessRes, species = 9)\n\n\n\n\n\nOriginal\n\n\n\n\n\nModified\n\n\n\n\n\nThe change seems small enough. However, now that we changed the availability of resources, which is so important for larval stages, these four species will experience a much reduced growth rate during their juvenile stage. We can see that effect by recalculating the single-species spectra with\n\nmp_lessRes_sss &lt;- steadySingleSpecies(mp_lessRes)\n\nand then ploting the spectra\n\nplotSpectra(mp_lessRes_sss, power = 2)\n\n\n\n\nWe can see the drastic reduction in the abundances of species 8 to 11.\n\n\n\n\n\n\nImportant\n\n\n\n\n\nIt is very important to understand that the above picture does not represent what will actually happen in the multi-species model. The above picture represents single-species thinking. We changed something for species 8 to 11 and then calculated the effect that change has on those species assuming they stayed in the same environment with the same prey and predator abundances. But of course the rest of the ecosystem will react, as we will now investigate."
  },
  {
    "objectID": "understand/species-interactions.html#trophic-cascades",
    "href": "understand/species-interactions.html#trophic-cascades",
    "title": "Species interactions",
    "section": "Trophic cascades",
    "text": "Trophic cascades\nAs we just discussed, the above picture does does not show a steady state of the ecosystem. Species now find themselves with a different abundance of predators and prey and this will change their mortality and their growth and hence their size spectra.\nThe easiest way to find the new steady state that the ecosystem will settle into is to simulate the full multi-species dynamics forward in time. Mizer refers to this simulation to find the future state of the ecosystem as “projecting”. We can use the function projectToSteady() to project forward in time far enough so the system has settled down again close to the new steady state.\n\nmp_lessRes_steady &lt;- projectToSteady(mp_lessRes)\n\nConvergence was achieved in 24 years.\n\n\n\nplotSpectra2(mp_lessRes_steady, name1 = \"less resource\", \n             mp, name2 = \"original\", \n             total = TRUE, power = 2, ylim = c(1e-8, NA), wlim = c(1e-3, NA))\n\n\n\n\nThere is much to see in this graph. We can see how the reduction in the abundance of large individuals leads to undulations in fish and resource size spectra, compared to the original model.\nFishing-induced cascades\nLet’s investigate these trophic cascades a bit more. This time we can look at how fishing large fish will affect the ecosystem.\nThe model has been set up with a knife-edge fishing gear that selects all individuals above 1kg, irrespective of species. This is not a realistic gear and mizer can do much better, as we will see in Part 3. But it serves our current purpose, because it will impose a fishing mortality that only impacts the larger species that actually grow to sizes above 1kg. To use that gear we just have to set a non-zero fishing effort. We create a new model mp_fishing with a fishing effort of 1:\n\nmp_fishing &lt;- mp\ninitial_effort(mp_fishing) &lt;- 1\n\nAs we did in the section on fishing mortality in the previous tutorial, we can visualise the direct effect that this fishing mortality has on individual species:\n\nmp_fishing_sss &lt;- steadySingleSpecies(mp_fishing)\nplotSpectra(mp_fishing_sss, power = 2)\n\n\n\n\nAs expected, the largest species have their abundances reduced above 1kg if they are fished, and if they continue to encounter the same amount of prey and are exposed to the same amount of predation mortality.\nAgain the important point is that the above picture does does not show a steady state of the ecosystem. You will look at the multi-species steady state in the next exercise to see if this fishing also leads to a trophic cascade.\n\n\n\n\n\n\nExercise 2\n\n\n\n\n\nProject the mp_fishing model to its steady state and then make a plot comparing it to the steady state of the un-fished system. Do you see a trophic cascade?\n\n\n\n\n\n\nShow me the solution\n\n\n\n\n\n\nmp_fishing_steady &lt;- projectToSteady(mp_fishing_sss)\n\nConvergence was achieved in 12 years.\n\nplotSpectra2(mp, name1 = \"No fishing\",\n             mp_fishing_steady, name2 = \"Fishing\",\n             power = 2,\n             wlim = c(1e-2, NA), ylim = c(1e-6, NA))\n\n\n\n\nThere is a clear trophic cascade."
  },
  {
    "objectID": "understand/species-interactions.html#summary-and-recap",
    "href": "understand/species-interactions.html#summary-and-recap",
    "title": "Species interactions",
    "section": "Summary and recap",
    "text": "Summary and recap\n\nWhen using mizer models it is very important to investigate who eats whom and where mortality comes from. We do this with the functions plotDeath() and plotDiet().\nThe contribution of different species to the diet of a predator depends on the abundances of the species in the size range preferred by the predator.\nThe species interaction matrix defines availability of each species to predation by other species. By changing the interaction matrix we can make our models more realistic and more complex.\nTrophic cascades are one of the coolest things in multi-species models and the reason we build these models. We want to understand how changes in one species and its sizes will affect the whole ecosystem. Mizer has many ways how we can explore such trophic cascades."
  },
  {
    "objectID": "understand/predation-growth-and-mortality.html",
    "href": "understand/predation-growth-and-mortality.html",
    "title": "Predation, growth and mortality",
    "section": "",
    "text": "It is now time to discuss the important issue of predation. It is through predation that a fish obtains the energy it needs to maintain its metabolism, to grow and to invest in reproduction. But also a large proportion of the natural mortality of fish comes from predation by their predators. So it is important how mizer models predation. While you can also read about the details in the description of the general mizer size-spectrum model, in this tutorial we will approach the topic in a more hands-on fashion, using the mizer package itself to experiment and help us build intuition.\nAs in the previous tutorial, we load the mizer, mizerExperimental and tidyverse packages and create a single-species model with a power-law background with exponent -2.05.\nlibrary(mizer)\nlibrary(mizerExperimental)\nlibrary(tidyverse)\nparams &lt;- newSingleSpeciesParams(lambda = 2.05)"
  },
  {
    "objectID": "understand/predation-growth-and-mortality.html#growth",
    "href": "understand/predation-growth-and-mortality.html#growth",
    "title": "Predation, growth and mortality",
    "section": "Growth",
    "text": "Growth\nEffect of prey availability\nThe energy income for a fish comes from predation on its prey. If there is less prey, the fish consumes less and its growth rate will decrease. Let us investigate this by artificially removing some prey. Because in our simple single-species model we work with a fixed community spectrum that is under our control, we can do that.\nBelow we decrease the community spectrum by a factor of 10 in the size range from 1mg to 10mg.\n\n# Create a new parameter object to be able to keep the old one unchanged.\nparams_starved &lt;- params\n\n# Create logical vector identifying the size bins we want to change. \n# Here `w_full(params)` returns a vector with all size bins in the model\nsize_range &lt;- w_full(params) &gt; 10^-3 & w_full(params) &lt; 10^-2\n\n# Divide the abundances in those size bins by 10\ninitialNResource(params_starved)[size_range] &lt;- \n    initialNResource(params)[size_range] / 10\n\nLet’s make a plot to check that this did what we intended:\n\n# The `species = FALSE` means that we will only plot the background\nplotSpectra(params_starved, power = 2, species = FALSE)\n\n\n\n\nThe plot shows the big drop in the background abundance in our selected size range. This reduced availability of prey in that size range will lead to a drop in the growth rate in the fish that feed in that size range. We can see the slow-down in growth by comparing the growth rates in the original model and the new model. We will use the method that we saw at the end of the previous tutorial in the section “Two curves in one plot”.\n\ngf_original &lt;- melt(getEGrowth(params))\ngf_original$Model &lt;- \"Original\"\ngf_starved &lt;- melt(getEGrowth(params_starved))\ngf_starved$Model &lt;- \"Less prey\"\ngf &lt;- rbind(gf_original, gf_starved)\ngrowth_rates_plot &lt;- ggplot(gf, aes(x = w, y = value, linetype = Model)) +\n    geom_line() +\n    scale_x_log10(\"Weight [g]\") +\n    ylab(\"Growth rate [g/year]\")\ngrowth_rates_plot\n\n\n\n\nThe slow-down occurs at a size that is about a factor of 100 larger than the size at which food is reduced. Why this is we will discuss in the next section.\nThe dip in the growth rate may not seem very significant in the above plot, but it has a dramatic effect on the steady state size distribution of our species. We know from the previous tutorial that we can set the abundances in the single-species model to the steady state value with\n\nparams_starved &lt;- steadySingleSpecies(params_starved)\n\nWe can now visualise the difference in the size spectra with the plotSpectra2() function:\n\nspectra_plot &lt;- plotSpectra2(params, name1 = \"Original\",\n                             params_starved, name2 = \"Less prey\",\n                             power = 2)\nspectra_plot\n\n\n\n\nThe lack of food and the resulting slow-down in growth leads to a severe drop in the density of large fish. Because fish do not get enough food and do not grow into the next size class, they are stuck in smaller size classes for a longer time and are affected by mortality, which is higher for small size classes.\nOne may think that the drop in abundance is at sizes where the predator encounters fewer prey than before and thus has lower growth rate. This is what classic predator-prey thinking would suggest: low prey abundance leads to low predator abundance. Size spectrum dynamics is different. To drive this point home we will display the growth rate plots and the spectrum plots directly above each other\n\n\n\ngrowth_rates_plot\nspectra_plot\n\n\n\n\n\n\n\n\n\nWe see that where the growth starts slowing down, the abundance actually increases. This is because a decrease in the growth rate leads to a pile-up of individuals. You know this phenomenon from traffic jams. Where the speed of the cars decreases on a motorway, their density increases. Then when the speed increases again on the other side of the traffic jam, the density of cars drops and you wonder what caused the traffic jam in the first place. We see the same phenomenon in size spectrum dynamics. We see from the graphs above: it is where the growth rate starts growing faster again that the density goes down.\n\n\n\n\n\n\nImportant\n\n\n\n\n\nThe above shows that size spectrum dynamics is very different from predator-prey dynamics.\n\n\n\nThe reduction of prey has led to a significant reduction in the overall abundance of the species. This is in spite of the fact that we have kept the abundance constant at the lowest size, i.e. we assumed that recruitment of new fish is not affected by what happens in larger size classes. In reality, the drastic reduction of spawning stock biomass will lead to a reduction in the number of eggs as well, so the effect will be even more dramatic.\nHere we hand over to you to investigate what happens when the prey abundance is increased instead of decreased. Please open the worksheet named “worksheet3-predation-growth-and-mortality.Rmd” in your worksheet repository, where you will find the following exercise:\n\n\n\n\n\n\nExercise 1\n\n\n\n\n\nMake a single plot, similar to the one above, comparing the steady state biomass density in log weight in the original model with that when the community abundance is increased by a factor of 10 in the size range from 1mg to 10mg.\n\n\n\n\n\n\nShow me the solution\n\n\n\n\n\n\nparams_overfed &lt;- params\ninitialNResource(params_overfed)[size_range] &lt;- \n    initialNResource(params)[size_range] * 10\n\nparams_overfed &lt;- steadySingleSpecies(params_overfed)\n\nplotSpectra2(params, name1 = \"Original\",\n             params_overfed, name2 = \"More prey\",\n             power = 2)"
  },
  {
    "objectID": "understand/predation-growth-and-mortality.html#how-predation-is-modelled",
    "href": "understand/predation-growth-and-mortality.html#how-predation-is-modelled",
    "title": "Predation, growth and mortality",
    "section": "How predation is modelled",
    "text": "How predation is modelled\nThe easiest case in which to understand predation is to imagine a filter-feeding fish, swimming around with its mouth open. Clearly the amount of food it takes in is determined by four things:\n\nthe density of prey in the water,\nhow much volume of water the fish is able to filter, which will depend on how fast it swims as well as on its gape size.\nwhat sizes of prey the fish is able to filter out of the water, which will be limited by its gape size and by how fine its gill rakers are,\nhow fast it can digest the food. If it can filter the prey faster than it can digest, it will have to start letting prey go uneaten.\n\nFor a more active hunter the situation will be similar. The rate at which it predates will depend on four things:\n\nthe density of prey in the water\nthe volume of water that the fish patrols and in which it will be able to seek out its prey. This may depend on things like radius of vision.\nwhich of this detected prey the fish is able to catch, which will depend on its mouth size but also on its agility and skill as well as on the defensive mechanisms of the prey.\nhow fast it can digest the food.\n\nOf these four factors, we have already been discussing the density of prey. In the next section we will discuss the ability to filter out or catch prey of particular sizes, which we model via the predation kernel. In the section after that we will discuss the search volume and then in the following section the maximum consumption rate.\nThe predation kernel\nFish will be particularly good at catching prey in a specific range of sizes, smaller than themselves. This is encoded in the size-spectrum model by the predation kernel. Let us take a look at the predation kernel in our model. We can obtain it with the function getPredKernel().\n\npred_kernel &lt;- getPredKernel(params)\n\nThis is a large three-dimensional array (predator species x predator size x prey size). We extract the kernel of a predator of size 10g (using that we remember that this is in size class 81)\n\npred_kernel_10 &lt;- pred_kernel[, 81, , drop = FALSE]\n\nThe drop = FALSE option is there to prevent R from dropping any of the array dimensions. We can now plot this as usual\n\nggplot(melt(pred_kernel_10)) +\n  geom_line(aes(x = w_prey, y = value)) +\n  scale_x_log10(limits = c(1e-4, 10))\n\nWarning: Removed 181 rows containing missing values (`geom_line()`).\n\n\n\n\n\nWe see that the predator of size 10g likes to feed on prey that is about the size of 0.1g, which is about 100 times smaller than itself. But it also feeds on other sizes, just with reduced preference. The preferred predator/prey size ratio is determined by the species parameter beta and the width of the feeding kernel, i.e., how fussy the predator is regarding their prey size, is determined by the species parameter sigma. beta is the preferred predator prey mass ratio or PPMR. Larger PPMR values mean that the predator prefers to feed on a relatively smaller prey (larger ratio). In our model these have the values\n\nselect(species_params(params), beta, sigma)\n\n\n\n  \n\n\n\nLet us change the preferred predator prey mass ratio from 100 to 1000. As usual, we first create a copy of the parameter object, then we make the change in that copy.\n\nparams_pk &lt;- params\nspecies_params(params_pk)$beta &lt;- 1000\n\nLet’s make a plot to see that the predation kernel has indeed changed.\n\ngetPredKernel(params_pk)[, 81, , drop = FALSE] %&gt;% \n  melt() %&gt;% \n  ggplot() +\n  geom_line(aes(x = w_prey, y = value)) +\n  scale_x_log10(limits = c(1e-4, 10))\n\nWarning: Removed 181 rows containing missing values (`geom_line()`).\n\n\n\n\n\nIf we now again reduce the prey in the size range from 1mg to 10mg as before, we now expect this to produce a peak in the biomass spectrum somewhere between 1g and 10g. Let’s check.\n\n# Put reduced resource abundance values into params_pk \ninitialNResource(params_pk) &lt;- initialNResource(params_starved)\n# Find the new steady state, because conditions have changed.\nparams_pk &lt;- steadySingleSpecies(params_pk)\n\nplotSpectra2(params_starved, name1 = \"beta = 100\",\n             params_pk, name2 = \"beta = 1000\",\n             power = 2)\n\n\n\n\nThe dip is indeed happening later.\n\n\n\n\n\n\nLinks to documentation\n\n\n\n\n\nFor details of how beta and sigma parametrise the predation kernel, see https://sizespectrum.org/mizer/reference/lognormal_pred_kernel.html#details. For information on how to change the predation kernel, see https://sizespectrum.org/mizer/reference/setPredKernel.html#setting-predation-kernel\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\n\nDo not confuse the prey preference with the diet. Just because a predator might prefer to feed on prey of a particular size if it had free choice does not mean that it actually feeds predominantly on such prey. The actual diet of the fish depends also on the availability of prey. Because smaller prey are more abundant, the realised predator prey mass ratio in the diet will be smaller than the preferred predator prey mass ratio. This is particularly important when estimating the predation kernel from stomach data.\n\n\n\nSearch volume\nNext we consider the factor that models the volume of water a filter feeder is able to filter in a certain amount of time, or the volume of water a predatory fish is able to patrol in a certain amount of time. This is difficult to model from first principles, although people have tried to argue in terms of swimming speeds of fish. We assume that this search volume rate is also an allometric rate. Let \\gamma(w), also called gamma, denote this rate for a predator of size w. Thus we assume that \\gamma(w) = \\gamma_0\\ w^q for some exponent q. We know that a fish needs to consume prey at a rate that scales with its body size to the power n, with n about 3/4. We also know that the prey density will be approximately described by a power law, i.e., that N(w) \\approx N_0\\ w^{-\\lambda}. A bit of maths then says that q = 2 - \\lambda + n. The formula is based on observations about size distributions and the fact that in the real world, evolution had made sure that the fish have developed a feeding strategy that allows it to cover its metabolic costs. Together this would have led to that search volume exponent of approximately q=2-\\lambda+n but of course in reality there is quite a bit of variability.\nThis is one of many powerful aspects about strong theoretical basis behind size based models. We can of course disagree with this assumption if we have evidence and data, but at least there is a basic assumption to base the discussion on.\nMost people using mizer rarely modify the default assumptions about the body scaling exponents and focus on more on the coefficients. So let us see what effect changing the coefficient \\gamma_0 in the search volume rate has. Its current value in our model is\n\nspecies_params(params)$gamma\n\n[1] 2066.004\n\n\nWe change that to 1000 and find the new steady state.\n\nparams_new_gamma &lt;- params\nspecies_params(params_new_gamma)$gamma &lt;- 1000\nparams_new_gamma &lt;- steadySingleSpecies(params_new_gamma)\n\nWe can see the effect in the growth curve of our species.\n\ngf_original &lt;- plotGrowthCurves(params, return_data = TRUE)\ngf_original$Model &lt;- \"Original\"\ngf_new &lt;- plotGrowthCurves(params_new_gamma, return_data = TRUE)\ngf_new$Model &lt;- \"Reduced search volume\"\n\nggplot(rbind(gf_original, gf_new), aes(x = Age, y = value, colour = Model)) +\n    geom_line()\n\n\n\n\nAs expected, the smaller search volume leads to a slower growth due to slower feeding rate.\nFeeding level\nIn mizer we assume that the feeding rate follows a Holling type II feeding curve. This means that feeding rate is increasing linearly with prey density at low prey density but then the increase slows down towards a maximum at high prey density due to the satiation of the predator. A predator will not be able to utilise food at a faster rate than its maximum intake rate. Of course in practice it will not feed at the maximum intake rate because of limited availability of prey. We describe this by the feeding level which is the proportion of its maximum intake rate at which the predator is actually taking in prey.\nIn our simple model this feeding level is constant across all fish body sizes (this is rarely the case in more realistic models, as you will see later).\n\nplotFeedingLevel(params) + theme(text = element_text(size = 20))\nplotFeedingLevel(params_new_gamma) + theme(text = element_text(size = 20))\n\n\n\n\n\nOriginal\n\n\n\n\n\nModified\n\n\n\n\n\nIn the model with the reduced search volume the feeding level is lower, as one would expect.\nThe feeding level will depend on the maximum intake, search rate and food availability. The maximum intake rate scales with body size with the exponent n = 3/4 and is determined by the coefficient h. So the maximum intake rate at size h(w) is modelled as h(w) = h w^n. Again, if we want to modify the maximum intake rate we usually change the coefficient h. We will do that in later tutorials. The current value of the coefficient h is\n\nspecies_params(params)$h\n\n[1] 30\n\n\nand is measured in gram of food per \\text{gram}^{-n} of predator weight per year (remember, maximum consumption scales with fish weight to the power of n)."
  },
  {
    "objectID": "understand/predation-growth-and-mortality.html#mortality",
    "href": "understand/predation-growth-and-mortality.html#mortality",
    "title": "Predation, growth and mortality",
    "section": "Mortality",
    "text": "Mortality\nPredation mortality\nOf course, feeding of the predator is only one aspect of predation. The other is the death of the prey. Feeding and mortality are coupled. Increased feeding and growth of one class of individuals will necessitate increased death of another. There is no free lunch.\nOnce we have specified the predation parameters, these parameters determine both the growth of predators but also the mortality rate of prey. So we don’t have to introduce new parameters for death from predation. Of course with a one-species model we cannot easily demonstrate this predation. We will explore predation more thoroughly in future tutorials.\nBackground and external mortality\nIn more realistic multi-species models, mortality also includes a baseline, size-independent mortality. This is also often called background mortality and it accounts for processes that are not related to predation, for example disease. This background mortality in mizer is assumed to depend on the maximum body size of a species, as you will see later.\nIn addition, mizer allows you to include other sources of external mortality. This could be predation from animals that we have not included in our model, like sea birds or mammals, death from old age (senescent death) and so on.\nFishing mortality\nThe cause of mortality that is most under our control is mortality from fishing. Mizer allows the simulation of mixed fisheries, utilising several different gears (or metiers or fleets) catching several different species. The parameters describing the fishing gears are stored in a gear_params data frame. If a particular gear can catch a particular species, there will be a corresponding row in the gear_params data frame specifying the catchability of that species for that gear as well as the size-selectivity of the gear for that species. We discuss in more detail how fishing is set up in mizer in Part 3 of this course when we study the consequences of changes in fishing policy.\nHere we only look at what fishing gear is set up by default in our simple single-species model:\n\ngear_params(params)\n\n\n\n  \n\n\n\nWe see that there is only one gear, called “knife_edge_gear” targeting our one species, called “Target species”. The size-selectivity is described by a knife_edge function with a knife_edge_size of about 25 grams. This means that all fish greater than about 25 grams will be exposed to the same fishing mortality while smaller fish will experience no fishing mortality. Mizer can of course also deal with more general selectivity curves.\nWe also need to specify the fishing effort, which will be multiplied by the catchability and the selectivity to get the annual instantaneous fishing mortality rate. For illustration we will set the effort to 1 and plot the resulting fishing mortality.\n\nparams_fishing &lt;- params\ninitial_effort(params_fishing) &lt;- 1\nplotFMort(params_fishing)\n\n\n\n\nThe reason why the function that we have used to set the effort is called initial_effort() is that later when we run simulations of the fisheries mizer allows us to specify how the fishing effort changes over time. For now let us just look at what the new steady state size spectrum of our species looks like when it is exposed to the constant fishing effort, compared to the unfished steady state.\n\nparams_fishing &lt;- steadySingleSpecies(params_fishing)\n\nplotSpectra2(params, name1 = \"No Fishing\",\n             params_fishing, name2 = \"Knife-edge\",\n             power = 2, wlim = c(10, NA))\n\n\n\n\nThe difference may not seem to be very big, but note that we are using a logarithmic scale on the y axis. At large sizes the biomass densities differ almost by a factor of 30."
  },
  {
    "objectID": "understand/predation-growth-and-mortality.html#summary-and-recap",
    "href": "understand/predation-growth-and-mortality.html#summary-and-recap",
    "title": "Predation, growth and mortality",
    "section": "Summary and recap",
    "text": "Summary and recap\n1) In a mizer model the growth curve is not fixed but instead the growth rate of an individual changes as the prey abundance changes. This makes it important to understand how fish choose their prey.\n2) A size spectrum model reacts differently to low prey abundance than a predator-prey model. In a size spectrum model when the growth rate of a predator slows down due to lack of prey, the abundance of predators of that size increases.\n3) A fish is assumed to have a feeding preference for prey in a range of sizes at a certain fraction of its own size. So as the fish grows up, its preference shifts to larger sizes, an effect known as ontogenetic diet shift.\n4) The search rate of a species determines the rate at which it can find food and thus influences its growth rate. In mizer this search rate is an allometric rate with exponent q which by default is set as q=2-\\lambda+n so that at least in the larval stage the growth rate scales with exponent n = 3/4.\n5) Fish have a maximum intake rate that scales with body size with exponent n = 3/4. Due to scarcity of prey they will only feed at a proportion of their maximum intake rate. This proportion is called the feeding level.\n6) Species size spectra depend strongly on mortality rates and in a realistic model this mortality rate will depend on the abundance of predators. We will explore this in greater detail in the next tutorials. Here we just looked at the effect of fishing mortality on the size spectrum."
  },
  {
    "objectID": "understand/index.html",
    "href": "understand/index.html",
    "title": "Part 1: Understand size-spectrum modelling",
    "section": "",
    "text": "Your goal in this first week of the course is to gain a thorough understanding of size spectra and their dynamics. This means that at the end of the week you will understand the parameters that shape the size spectra and how size spectra respond to changes. You will have a feel for how size-spectrum dynamics is different from usual single-species age-based dynamics.\nIt is worth expending effort on building this understanding in this first part of the course, because it will enable you to build more reliable models in the second part and to appropriately explore the model predictions in the third part."
  },
  {
    "objectID": "understand/index.html#tutorials",
    "href": "understand/index.html#tutorials",
    "title": "Part 1: Understand size-spectrum modelling",
    "section": "Tutorials",
    "text": "Tutorials\nThe material for this week is split into 5 tutorials:\n\nObserved size spectra\nBecause many of the physiological rates in fish (like growth, mortality, metabolism, reproduction) depend on the size of the individuals, a mizer model needs to keep track of the size distributions of the populations, the so-called size spectra. To get a feel for size spectra, in this first tutorial you will take observational data and make plots of size spectra. There is confusion in the size spectrum literature because there are different ways to represent the size spectra and this tutorial will introduce these, so that you can cut through the confusion.\nSingle-species spectra\nAt the community level, size spectra tend to look like power laws. But the size spectrum of each individual species making up the community will look different. In this tutorial we will investigate how the shape of the single species spectrum is determined by an interplay of growth and mortality.\nPredation, growth and mortality\nA particular strength of a mizer model is that growth curves and mortality rates are not fixed externally but are emergent and dependent on the availability of prey and the presence of predators. In this tutorial we explore how predation is modelled in mizer and how it effects growth and mortality.\nSpecies interactions\nIn a mizer model all the species in the community interact with each other through size-based predation. So any changes in one species’ size spectrum affects the size spectra of the other species, which in turn affects that first species. In this tutorial we start investigating some of the effects this has.\nDynamics of spectra\nIn previous tutorials we have concentrated on the steady state of the mizer model, where for each size class and each species, the rate at which individuals grow into the size class balances the rate at which individuals grow out of the size class or die, thus keeping the size spectrum constant. In this tutorial we explore the dynamic that takes place when this balance is changed."
  },
  {
    "objectID": "understand/index.html#video-introduction",
    "href": "understand/index.html#video-introduction",
    "title": "Part 1: Understand size-spectrum modelling",
    "section": "Video Introduction",
    "text": "Video Introduction\nIn this video, Ken Andersen introduces many of the concepts that we will be discussing in this course. However, don’t feel that you have to take it all in at once. We will come back to these topics (and others) during the course where we hope to make them concrete by working hands-on with mizer."
  },
  {
    "objectID": "prepare/install-tools.html",
    "href": "prepare/install-tools.html",
    "title": "Install tools",
    "section": "",
    "text": "For this course you will need access to a machine with an installation of R, a development environment like RStudio and some important R packages, including, of course, mizer itself and mizerExperimental. Below we give the necessary information to allow you to install these tools.\nIf you run into difficulties, please make a post in the Comments section at the bottom of this page. We will try to help you as quickly as possible. If you have a question, then it is likely that others will have the same question, so please do not hesitate to ask.\nIf you already have some of these tools installed, please make sure that the version you have is recent."
  },
  {
    "objectID": "prepare/install-tools.html#r",
    "href": "prepare/install-tools.html#r",
    "title": "Install tools",
    "section": "R",
    "text": "R\nMizer is compatible with R versions 3.1 and later. However in this course we will assume that you have a version newer than 4.0. So if you are still using 3.x, now is the time to upgrade. You can install or upgrade R on your computer by following the instructions at https://cran.r-project.org/ for your particular platform. In fact, upgrading follows the same procedure as installing from scratch.\nAlternatively, if you can not or do not want to install R on your computer, you can also work with R and RStudio in your internet browser by creating yourself a free account at https://posit.cloud. There you can then install mizer as described below. Running mizer in the RStudio Cloud may be slightly slower than running it locally on your machine, but the speed is usually quite acceptable."
  },
  {
    "objectID": "prepare/install-tools.html#rstudio",
    "href": "prepare/install-tools.html#rstudio",
    "title": "Install tools",
    "section": "RStudio",
    "text": "RStudio\nThe tutorials in this course assume that you are using RStudio to work with R. If you prefer to use a different R environment, then you may need to translate some of the instructions to how things are in your R environment.\nRStudio develops rapidly and adds useful features all the time and so it is best if you install the latest version. This course was written with version 2023.06.0. If you already have RStudio installed but it is an older version, the way to upgrade is to just install the newest version. The old version will automatically be replaced by the new.\nIf you are new to RStudio, the video on the RStudio IDE homepage is well worth watching."
  },
  {
    "objectID": "prepare/install-tools.html#r-packages",
    "href": "prepare/install-tools.html#r-packages",
    "title": "Install tools",
    "section": "R Packages",
    "text": "R Packages\nR packages extend the functionality of R. mizer itself is such an R package. There is a central repository for R packages called CRAN which hosts all of the packages needed for this course, except for the mizerExperimental package. To install them on your computer just start RStudio and then in the console issue the command\n\ninstall.packages(c(\"mizer\", \"tidyverse\", \"plotly\", \"remotes\", \"usethis\",\n                   \"rmarkdown\", \"rstudioapi\"))\n\nThe mizerExperimental package is for code that is still experimental and thus changes frequently. Therefore it is hosted in a GitHub repository. You install it with\n\nremotes::install_github(\"sizespectrum/mizerExperimental\", ref = \"2f7d4ca\")\n\nThis may give you a list of other packages that you have already installed that have newer versions available and ask you to specify which ones you want to update. For the purpose of this course it probably will not be important, so if you like you can skip the updates for now.\nNote the ref argument to install_github(). It specifies which particular version of the code you want to install. This makes sure that the version you install will behave as expected in this course. Unlike the mizer package, the mizerExperimental package does not promise that newer versions remain backwards compatible to earlier versions. So if you want reproducible code it will be best to install a fixed version."
  },
  {
    "objectID": "prepare/install-tools.html#checking-your-installation",
    "href": "prepare/install-tools.html#checking-your-installation",
    "title": "Install tools",
    "section": "Checking your installation",
    "text": "Checking your installation\nTo check that everything works, copy and paste and then run the following code:\n\nif (getRversion() &lt; \"4.0\") warning(\"Your version of R is too old.\")\nif (packageVersion(\"mizer\") &lt; \"2.4.1\") warning(\"Your version of mizer is too old.\")\nif (packageVersion(\"mizerExperimental\") != \"2.4.0.9004\") warning(\"You are using a different version of MizerExperimental. Please reinstall with the command given above.\")\nif (packageVersion(\"tidyverse\") &lt; \"1.3.0\") warning(\"Your version of tidyverse is very old. While this may not create a problem, updating it is nevertheless advised.\")\nlibrary(mizer)\nlibrary(mizerExperimental)\nplotDeath(NS_params)\n\n\n\n\nIf you do not get any “Warning” or “Error”, then everything is fine. If you experience problems, see below."
  },
  {
    "objectID": "prepare/install-tools.html#issues-and-discussions",
    "href": "prepare/install-tools.html#issues-and-discussions",
    "title": "Install tools",
    "section": "Issues and Discussions",
    "text": "Issues and Discussions\nYou will find a comment section at the bottom of each course webpage. Please use it a lot to share your questions, thoughts and experiences as you go through the course. As with all computer-related things, unexpected problems are likely to crop up. Be sure to post about them in the Comments section.\nWhen you post a comment you will be asked to log in to GitHub. You will probably already have an account on GitHub. If not, please create one for yourself. GitHub is the most common way for researchers to share their research code and the source material for this course is also hosted there, as is the mizer package itself. So it is a good idea to have an account there anyway.\nYou can use Markdown syntax in your post. The comments are threaded discussions.\nThe comments you post on this course website will also appear in the Comments section of the GitHub discussions for the course repository. Even after posting a comment you can go and edit the post on GitHub and it will be updated on this website as well.\nInstead of posting a comment, you can also report issues by clicking on the “Report an issue” link that you find at the bottom of the right side-bar. That will create an entry in the GitHub issue tracker.\nIf you have a correction to a page or want to suggest an edit, use the “Edit this page” link. Don’t worry: we will need to approve your edits before they go live, so you can feel free to edit as much as you like.\nYou will find the “Edit this page” and “Report an issue” links on every tutorial page and you will find a comments section on every page of the course website. Never hesitate to use them."
  },
  {
    "objectID": "index.html#tutorials",
    "href": "index.html#tutorials",
    "title": "Online course",
    "section": "Tutorials",
    "text": "Tutorials\nThe course has three parts, each consisting of several tutorials.\n\nPart 1: Understand\nYou will gain an understanding of size spectra and their dynamics by exploring simple example systems hands-on with mizer.\nPart 2: Build\nYou will build your own multi-species mizer model for the Celtic sea, following our example. You can also create a model for your own area of interest.\nPart 3: Use\nYou will explore the effects of changes in fishing and changes in resource dynamics on the fish community and the fisheries yield. You will run your own model scenarios.\n\nThere are exercises dotted throughout the tutorials.\nTo get started, install the tools you need and then go to Part 1 to learn about size spectra and their dynamics.\n\nThis course was developed by Gustav Delius at the University of York as part of the Pyramids of Life, funded by UK Research and Innovation via the Sustainable Management of Marine Resources fund. It builds on an earlier collaboration with Asta Audzijonyte as a part of the Sustainable inland fisheries project, funded by the European Regional Development Fund."
  },
  {
    "objectID": "understand/dynamics-of-spectra.html",
    "href": "understand/dynamics-of-spectra.html",
    "title": "Dynamics of size spectra",
    "section": "",
    "text": "In previous tutorials we have concentrated on the steady state of the mizer model, where for each size class and each species, the rate at which individuals grow into the size class balances the rate at which individuals grow out of the size class or die, thus keeping the size spectrum constant. In this tutorial we explore the dynamic that takes place when this balance is changed.\nSize-spectrum dynamics is described by the beautiful partial differential equation\n\n\\frac{\\partial N(w)}{\\partial t} + \\frac{\\partial g(w) N(w)}{\\partial w}\n  = -\\mu(w) N(w)\n\ntogether with the boundary condition\n\nN(w_{min}) = \\frac{R_{dd}}{g(w_{min})},\n\nwhere N(w) is the number density at size w, g(w) is the growth rate and \\mu(w) is the death rate of individuals of size w, w_{min} is the egg size and R_{dd} is the birth rate. Luckily it is easy to describe in words what these equations are saying.\n\n\n\n\n\n\nImportant\n\n\n\n\n\nSize spectrum dynamics is very intuitive: The rate at which the number of individuals in a size class changes is the difference between the rate at which individuals are entering the size class and the rate at which they are leaving the size class. Individuals can enter a size class by growing in or, in the case of the smallest size class, by being born into it. They can leave by growing out or by dying.\n\n\n\nWhat makes these seemingly obvious dynamics interesting is how the growth rate and the death rate are determined in terms of the abundance of prey and predators and the feeding preferences and physiological parameters of the individuals. We have discussed a bit of that in previous tutorials and will discuss it much more in upcoming tutorials. We will discuss the birth rate R_{dd} below in the section on how reproduction is modelled. But first we want to look at the results of simulating the size spectrum dynamics.\n\nlibrary(mizer)\nlibrary(mizerExperimental)\nlibrary(tidyverse)\n\n\nIn the previous tutorial, in the section on trophic cascades, we already simulated the size-spectrum dynamics to find the new steady state. But we only looked at the final outcome once the dynamics had settled down to the new steady state. We reproduce the code here:\n\n# Create trait-based model\nmp &lt;- newTraitParams() |&gt; \n    # run to steady state with constant reproduction rate\n    steady() |&gt;\n    # turn of reproduction and instead keep egg abundance constant\n    setRateFunction(\"RDI\", \"constantEggRDI\") |&gt;\n    setRateFunction(\"RDD\", \"noRDD\")\n\n# We make a copy of the model\nmp_lessRes &lt;- mp\n# and set the resource interaction to 0.8 for species 8 to 11\nspecies_params(mp_lessRes)$interaction_resource[8:11] &lt;- 0.8\n\n# We run the dynamics until we reach steady state\nmp_lessRes_steady &lt;- projectToSteady(mp_lessRes)\n\n# We compare the steady states\nplotSpectra2(mp_lessRes_steady, name1 = \"less resource\", \n             mp, name2 = \"original\",\n             total = TRUE, power = 2,\n             ylim = c(1e-8, NA), wlim = c(1e-3, NA))\n\n\n\n\nBut we can also save and then display the spectra of all the species at intermediate times. This is what the project() function does. It projects the current state forward in time and saves the result of that simulation in a larger object, a MizerSim object, which contains the resulting time series of size spectra. Let’s use it to project forward by 24 years.\n\nsim_lessRes &lt;- project(mp_lessRes, t_max = 24)\n\nWe can now use this MizerSim object in the animateSpectra() function to create an animation showing the change in the size spectra over time.\n\nanimateSpectra(sim_lessRes, total = TRUE, power = 2, \n               ylim = c(1e-8, NA), wlim = c(1e-3, NA))\n\n\n\n\n\nGo ahead, press the Play button.\nNote, for some species size spectra at the largest size class drop all the way to very small values (e.g. 10^-7) and for others they stop higher. This is just a discretisation artefact and is not important. Try to ignore it.\nOf course we can also get at the numeric values of the spectra at different times. First of all the function getTimes() gives the times at which simulation results are available in the MizerSim object:\n\ngetTimes(sim_lessRes)\n\n [1]  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24\n\n\nThe simulation results have been saved at yearly intervals. We could have changed that via the t_save argument to project().\nThe function N() returns a three-dimensional array (time x species x size) with the number density of consumers. To get for example the number density for the 2nd species after 5 years in the 1st size class we do\n\nN(sim_lessRes)[6, 2, 1]\n\n[1] 2.621407\n\n\nThe function getBiomass() acting on a MizerSim object returns an array (time x species) containing the total biomass in grams at each time step for each species. So for example the biomass in grams of the 2nd species after 5 years is\n\ngetBiomass(sim_lessRes)[6, 2]\n\n[1] 0.003434511\n\n\nThe biomass time series can be plotted with plotBiomass():\n\nplotBiomass(sim_lessRes)\n\n\n\n\nMizer provides many more functions to analyse the results of a simulation, some of which you will learn about later in this course."
  },
  {
    "objectID": "understand/dynamics-of-spectra.html#size-spectrum-dynamics",
    "href": "understand/dynamics-of-spectra.html#size-spectrum-dynamics",
    "title": "Dynamics of size spectra",
    "section": "",
    "text": "In previous tutorials we have concentrated on the steady state of the mizer model, where for each size class and each species, the rate at which individuals grow into the size class balances the rate at which individuals grow out of the size class or die, thus keeping the size spectrum constant. In this tutorial we explore the dynamic that takes place when this balance is changed.\nSize-spectrum dynamics is described by the beautiful partial differential equation\n\n\\frac{\\partial N(w)}{\\partial t} + \\frac{\\partial g(w) N(w)}{\\partial w}\n  = -\\mu(w) N(w)\n\ntogether with the boundary condition\n\nN(w_{min}) = \\frac{R_{dd}}{g(w_{min})},\n\nwhere N(w) is the number density at size w, g(w) is the growth rate and \\mu(w) is the death rate of individuals of size w, w_{min} is the egg size and R_{dd} is the birth rate. Luckily it is easy to describe in words what these equations are saying.\n\n\n\n\n\n\nImportant\n\n\n\n\n\nSize spectrum dynamics is very intuitive: The rate at which the number of individuals in a size class changes is the difference between the rate at which individuals are entering the size class and the rate at which they are leaving the size class. Individuals can enter a size class by growing in or, in the case of the smallest size class, by being born into it. They can leave by growing out or by dying.\n\n\n\nWhat makes these seemingly obvious dynamics interesting is how the growth rate and the death rate are determined in terms of the abundance of prey and predators and the feeding preferences and physiological parameters of the individuals. We have discussed a bit of that in previous tutorials and will discuss it much more in upcoming tutorials. We will discuss the birth rate R_{dd} below in the section on how reproduction is modelled. But first we want to look at the results of simulating the size spectrum dynamics.\n\nlibrary(mizer)\nlibrary(mizerExperimental)\nlibrary(tidyverse)\n\n\nIn the previous tutorial, in the section on trophic cascades, we already simulated the size-spectrum dynamics to find the new steady state. But we only looked at the final outcome once the dynamics had settled down to the new steady state. We reproduce the code here:\n\n# Create trait-based model\nmp &lt;- newTraitParams() |&gt; \n    # run to steady state with constant reproduction rate\n    steady() |&gt;\n    # turn of reproduction and instead keep egg abundance constant\n    setRateFunction(\"RDI\", \"constantEggRDI\") |&gt;\n    setRateFunction(\"RDD\", \"noRDD\")\n\n# We make a copy of the model\nmp_lessRes &lt;- mp\n# and set the resource interaction to 0.8 for species 8 to 11\nspecies_params(mp_lessRes)$interaction_resource[8:11] &lt;- 0.8\n\n# We run the dynamics until we reach steady state\nmp_lessRes_steady &lt;- projectToSteady(mp_lessRes)\n\n# We compare the steady states\nplotSpectra2(mp_lessRes_steady, name1 = \"less resource\", \n             mp, name2 = \"original\",\n             total = TRUE, power = 2,\n             ylim = c(1e-8, NA), wlim = c(1e-3, NA))\n\n\n\n\nBut we can also save and then display the spectra of all the species at intermediate times. This is what the project() function does. It projects the current state forward in time and saves the result of that simulation in a larger object, a MizerSim object, which contains the resulting time series of size spectra. Let’s use it to project forward by 24 years.\n\nsim_lessRes &lt;- project(mp_lessRes, t_max = 24)\n\nWe can now use this MizerSim object in the animateSpectra() function to create an animation showing the change in the size spectra over time.\n\nanimateSpectra(sim_lessRes, total = TRUE, power = 2, \n               ylim = c(1e-8, NA), wlim = c(1e-3, NA))\n\n\n\n\n\nGo ahead, press the Play button.\nNote, for some species size spectra at the largest size class drop all the way to very small values (e.g. 10^-7) and for others they stop higher. This is just a discretisation artefact and is not important. Try to ignore it.\nOf course we can also get at the numeric values of the spectra at different times. First of all the function getTimes() gives the times at which simulation results are available in the MizerSim object:\n\ngetTimes(sim_lessRes)\n\n [1]  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24\n\n\nThe simulation results have been saved at yearly intervals. We could have changed that via the t_save argument to project().\nThe function N() returns a three-dimensional array (time x species x size) with the number density of consumers. To get for example the number density for the 2nd species after 5 years in the 1st size class we do\n\nN(sim_lessRes)[6, 2, 1]\n\n[1] 2.621407\n\n\nThe function getBiomass() acting on a MizerSim object returns an array (time x species) containing the total biomass in grams at each time step for each species. So for example the biomass in grams of the 2nd species after 5 years is\n\ngetBiomass(sim_lessRes)[6, 2]\n\n[1] 0.003434511\n\n\nThe biomass time series can be plotted with plotBiomass():\n\nplotBiomass(sim_lessRes)\n\n\n\n\nMizer provides many more functions to analyse the results of a simulation, some of which you will learn about later in this course."
  },
  {
    "objectID": "understand/dynamics-of-spectra.html#reproduction-dynamics",
    "href": "understand/dynamics-of-spectra.html#reproduction-dynamics",
    "title": "Dynamics of size spectra",
    "section": "Reproduction dynamics",
    "text": "Reproduction dynamics\nThe above simulation was run with constant abundance in the smallest size class for each species. This of course is not realistic. The abundance of the smallest individuals depends on the rate at which mature individuals spawn offspring, and this in turn depends, among other things, on the abundance of mature individuals. So if the abundance of mature individuals goes down drastically, as it did for species 8 to 11 above, then the abundance of offsprings for those species will go down as well.\nTo see the effect we run the same code as above after deleting the two lines that turned off the reproduction dynamics. We also specify with t_save = 2 that we want to save the spectrum only every second year, which speeds up the display of the animation.\n\n# Create trait-based model and run to steady state\nmp &lt;- newTraitParams() |&gt; steady()\n\n# We make a copy of the model\nmp_lessRes &lt;- mp\n# and set the resource interaction to 0.8 for species 8 to 11\nspecies_params(mp_lessRes)$interaction_resource[8:11] &lt;- 0.8\n\n# We simulate the dynamics for 30 years, saving only every 2nd year\nsim_lessRes &lt;- project(mp_lessRes, t_max = 30, t_save = 2)\n\n# We animate the result\nanimateSpectra(sim_lessRes, total = TRUE, power = 2, \n               ylim = c(1e-8, NA), wlim = c(1e-3, NA))\n\n\n\n\n\nNote that now the fish species whose access to resources was decreased continue to decrease in abundance as time goes on. Interestingly, species 1 appears to be driven to extinction by the increased abundance of its predators that in turn is due to the decrease in predation from the larger species.\nGiven that reproduction has such an important impact on the response of species to fishing, it is worth taking a look at how reproduction is modelled in mizer.\nEnergy invested into reproduction\nWe already discussed the investment into reproduction in an earlier tutorial. As mature individuals grow, they invest an increasing proportion of their income into reproduction and at their asymptotic size they would be investing all income into reproduction. Summing up all these investments from mature individuals of a particular species gives the total rate E_R at which that species invests energy into reproduction. This total rate of investment is multiplied by a reproduction efficiency factor erepro, divided by a factor of 2 to take into account that only females reproduce, and then divided by the egg weight w_min to convert it into the rate at which eggs are produced. The equation is:\n\nR_{di} = \\frac{\\rm{erepro}}{2 w_{min}} E_R.\n\nThis is calculated in mizer with getRDI():\n\ngetRDI(mp)\n\n          1           2           3           4           5           6 \n0.344090412 0.211705188 0.130253809 0.080140004 0.049306967 0.030336622 \n          7           8           9          10          11 \n0.018664921 0.011483786 0.007065518 0.004347133 0.002674619 \n\n\nThe erepro parameter or reproduction efficiency can vary between 0 and 1 (although 0 would be bad) and gives the proportion of energy invested into reproduction that is converted into viable eggs or larvae.\nDensity-dependence in reproduction\nNote that mizer models the rate of egg production. The size spectrum dynamics then determine how many of those larvae grow up and survive to be recruited to the fishery.\n\n\n\n\n\n\nImportant\n\n\n\n\n\nThe stock-recruitment relationship is an emergent phenomenon in mizer, with several sources of density dependence. Firstly, the amount of energy invested into reproduction depends on the energy income of the spawners, which is density-dependent due to competition for prey. Secondly, the proportion of larvae that grow up to recruitment size depends on the larval mortality, which depends on the density of predators, and on larval growth rate, which depends on density of prey.\n\n\n\nHowever, there are other sources of density dependence that are not explicitly modelled mechanistically in mizer. An example would be a limited carrying capacity of suitable spawning grounds and other spatial effects. So mizer has another species parameter R_{max} that gives the maximum possible rate of recruitment. Imposing a finite maximum reproduction rate leads to a non-linear relationship between energy invested and eggs hatched. This density-dependent reproduction rate R_{dd} is given by a Beverton-Holt type function:\n R_{dd} = R_{di} \\frac{R_{max}}{R_{di} + R_{max}}\nRather than looking at the formula, let’s look at a figure:\n\n\n\n\n\nThis figure shows two graphs of R_{dd} (solid lines), one for higher R_{max} (black) and one for lower R_{max} (blue). The values of R_{max} are indicated by the dotted lines. The dashed lines show the density-independent rate R_{di}. Both graphs are for the same amount E_R of energy invested into reproduction.\nThe important fact to observe is that the solid curves becomes more shallow as R_{max} gets closer to the actual reproduction rate R_{dd}. This slope determines how big the effect of a change in investment into reproduction (for example due to a change in spawning stock biomass) is on the reproduction rate. As the energy invested in reproduction changes away from the steady state value E_R on the x-axis, the the solid curves shows how much the reproduction rate changes on the y-axis. The change is smaller along the shallower blue line, the one that corresponds to the R_{max} value that is closer to R_{dd}. The result is that a species with a low ratio between R_{max} and R_{dd} will be less impacted by depletion of its spawning stock by fishing, for example. This ratio we will refer to as the reproduction level and we will discuss it in the next section.\nThis density-dependent rate of reproduction is calculated in mizer with getRDD():\n\ngetRDD(mp)\n\n          1           2           3           4           5           6 \n0.258067809 0.158778891 0.097690357 0.060105003 0.036980226 0.022752467 \n          7           8           9          10          11 \n0.013998691 0.008612839 0.005299139 0.003260350 0.002005964 \n\n\nThis is the rate at which new individuals are entering the smallest size class. The actual number density in the smallest size class is then determined by the usual size-spectrum dynamics.\nReproduction level\nWe have seen the two species parameters that determine how the energy invested into reproduction is converted to the number of eggs produced: erepro and R_max. For neither of these is it obvious what value they should have. The choice of values influences two important properties of a model: the steady state abundances of the species and the density-dependence in reproduction. It is therefore useful to change to a new set of two parameters that reflect these two properties better. These are:\n\nThe birth rate R_{dd} at steady state. This determines the abundance of a species.\nThe ratio between R_{dd} and R_{max} at steady state. This determines the degree of density dependence.\n\nThe ratio R_{dd} / R_{max} we denote as the reproduction level. This name may remind you of the feeding level, which was the ratio between the actual feeding rate and the maximum feeding rate and described the level of density dependence coming from satiation. It takes a value between 0 and 1. It follows from our discussion in the previous section that a species with a high reproduction level is more resilient to changes.\nWe can get the reproduction levels of the different species with getReproductionLevel():\n\ngetReproductionLevel(mp)\n\n   1    2    3    4    5    6    7    8    9   10   11 \n0.25 0.25 0.25 0.25 0.25 0.25 0.25 0.25 0.25 0.25 0.25 \n\n\nWe see that by default newTraitParams() had given all species the same reproduction level. We can change the reproduction level with the setBevertonHolt() function. We can set different reproduction levels for each species, but here we will simply set it to 0.9 for all species:\n\nmp9 &lt;- setBevertonHolt(mp, reproduction_level = 0.9)\n\nChanging the reproduction level has no effect on the steady state, because that only depends on the rate of egg production R_{dd} and that is kept fixed when changing the reproduction level. We can check that by running our new model to steady state and plotting that steady state together with the original steady state.\n\nmp9 &lt;- projectToSteady(mp9)\n\nConvergence was achieved in 3 years.\n\nplotSpectra2(mp, name1 = \"reproduction_level = 0.25\",\n             mp9, name2 = \"reproduction_level = 0.9\",\n             total = TRUE, power = 2, ylim = c(1e-8, NA), wlim = c(1e-3, NA))\n\n\n\n\nThey overlap perfectly. However the reproduction level does have an effect on how sensitive the system is to changes. As an example, let us look at the dynamics that is triggered by the reduction in interaction with the resource by species 8 through 11.\n\n# We make a copy of the model\nmp_lessRes9 &lt;- mp9\n# and set the resource interaction to 0.8 for species 8 to 11\nspecies_params(mp_lessRes9)$interaction_resource[8:11] &lt;- 0.8\n\nsim_lessRes9 &lt;- project(mp_lessRes9, t_max = 30, t_save = 2)\n\nanimateSpectra(sim_lessRes9, total = TRUE, power = 2, \n               ylim = c(1e-8, NA), wlim = c(1e-3, NA))\n\n\n\n\n\nNotice how the species have settled down to a new steady state after 30 years without any extinctions and the impact on species 1 is much less extreme. As expected, the higher reproduction level has made the species more resilient to perturbations.\nThe problem of course is that in practice the reproduction level is hardly ever known. Instead, one will need to use any information one has about the sensitivity of the system from observed past perturbations to calibrate the reproduction levels. We’ll discuss this again towards the end of Part 2.\n\n\n\n\n\n\nExercise 1\n\n\n\n\n\nGo back to the example with fishing on individuals above 1kg from the section on fishing-induced cascades. Impose the same fishing, but now on the trait-based model with reproduction dynamics left turned on and with a reproduction level of 0.5 for all species. Project the model for 20 years and animate the result.\n\n\n\n\n\n\nShow me the solution\n\n\n\n\n\n\n# We make a copy of the trait-based model\nmp_fishing &lt;- mp\n# Set the reproduction level set to 0.5 for all species\nmp_fishing &lt;- setBevertonHolt(mp, reproduction_level = 0.5)\n# Set fishing effort to 1\ninitial_effort(mp_fishing) &lt;- 1\n\n# Simulate the dynamics for 20 years\nsim_fishing &lt;- project(mp_fishing, t_max = 20, t_save = 2)\n\n# Animate the result\nanimateSpectra(sim_fishing, total = TRUE, power = 2, \n               ylim = c(1e-8, NA), wlim = c(1e-3, NA))"
  },
  {
    "objectID": "understand/dynamics-of-spectra.html#resource-dynamics",
    "href": "understand/dynamics-of-spectra.html#resource-dynamics",
    "title": "Dynamics of size spectra",
    "section": "Resource dynamics",
    "text": "Resource dynamics\nThe resource spectrum is not described by size spectrum dynamics, because in reality it is typically not made up of individuals that grow over a large size range during their life time. In mizer, the resource number density in each size class is describe by semichemostat dynamics: the resource number density in each size class recovers after depletion, and this biomass growth or recovery rate will decrease as the number density gets close to a carrying capacity. If you want the mathematical details, you can find them in the mizer model description in the section on resource density.\nThe effect of these dynamics is that if the number of fish consuming the resource in a certain size range increases, the resource abundance in that size range will decrease, if it cannot recover quickly enough (regeneration rate of the resource is set by the user). So there is competition for the resource, which provides a stabilising influence on the fish abundances. We will be discussing this more in later tutorials."
  },
  {
    "objectID": "understand/dynamics-of-spectra.html#summary-and-recap",
    "href": "understand/dynamics-of-spectra.html#summary-and-recap",
    "title": "Dynamics of size spectra",
    "section": "Summary and recap",
    "text": "Summary and recap\n1) Size spectrum dynamics is very intuitive: the rate at which the number of individuals in a size class changes is the difference between the rate at which individuals grow into (or are born into) the size class and the rate at which individuals grow out of or the size class or die in the size class.\n2) The project() function simulates the dynamics and creates a MizerSim object that contains the resulting time series of size spectra.\n3) Mizer provides many functions for extracting, analysing and plotting the results of a simulation, some of which we will be using in Part 3.\n4) Instead of a stock-recruitment relationship as used in other fisheries models, a mizer model relates the energy invested into reproduction to the number of eggs produced. The growth and mortality that the larvae experience until they are recruited to the fishery lead to density-dependence in the recruitment. Additional density dependence is applied to the egg production.\n5) The relation between energy invested in reproduction and the actual birth rate is described by two parameters: the density independent reproduction efficiency erepro and the maximum birth rate R_max.\n6) In practice a more useful way to parametrise the reproduction is by two other parameters: the birth rate R_{dd} at steady state (which determines the total abundance of a species) and the reproduction level (which determines the amount the amount of density dependence that applies to egg production).\n7) A change in the reproduction level does not change the steady state but it changes the sensitivity of a species and the system to changes.\n8) The resource abundance is also dynamic and thus decreases when there is increased consumption, which has a stabilising effect on the fish community."
  },
  {
    "objectID": "understand/dynamics-of-spectra.html#recap-of-part-1",
    "href": "understand/dynamics-of-spectra.html#recap-of-part-1",
    "title": "Dynamics of size spectra",
    "section": "Recap of Part 1",
    "text": "Recap of Part 1\nCongratulations. You have reached the end of Part 1 of the mizer course.\nYou have learned to understand plots of size spectra and how the size-spectra are shaped by the interplay between growth and mortality. You have seen that both growth and mortality are emergent effects in mizer, both being caused by predation and thus dependent on the abundance of predator and prey. You appreciate that size-spectrum dynamics is very different from usual predator-prey dynamics, because the abundance of prey affects the growth rate of the predator rather than its abundance. You have seen the interesting trophic cascades that result from the size-based interaction between predator and prey. Finally you learned that stock-recruitment relationships are also emergent phenomena in mizer.\nThis was a lot to take in. You will probably want to come back to some of these ideas while you learn how to build mizer models in Part 2 of the course."
  },
  {
    "objectID": "understand/observed-size-spectra.html",
    "href": "understand/observed-size-spectra.html",
    "title": "Observed size spectra",
    "section": "",
    "text": "In this tutorial you will take observational data of fish sizes and plot the resulting size spectra for the community and for individual species. This will give you a concrete understanding of what size spectra are. There are various different ways of how size spectra can be represented, and this is a common source of confusion. Hence this tutorial is quite long, so let us start by giving a summary. We’ll then repeat the summary at the end of the tutorial by which time the points in the summary will hopefully make perfect sense to you."
  },
  {
    "objectID": "understand/observed-size-spectra.html#summary",
    "href": "understand/observed-size-spectra.html#summary",
    "title": "Observed size spectra",
    "section": "Summary",
    "text": "Summary\n1) It is very useful for fisheries policy to know how many fish of different sizes there are. This is what size spectra show.\n2) We can represent size spectra in different ways. One is to bin the data into size classes and plot histograms. The drawback is that the height of the bars in a histogram depend on our choice of bins. A bin from 1 to 2g will have fewer individuals than a bin from 1 to 10g.\n3) To avoid the dependence on bin sizes, we use densities, where the total number of individuals or the total biomass of individuals in each bin is divided by the width of the bin. We refer to these as the number density and the biomass density respectively.\n3) The number density looks very different from the biomass density. There will be a lot of very small individuals, so the number density at small sizes will be large, but each individual weighs little, so their total biomass will not be large.\n5) Community size spectra are approximately power laws. When displayed on log-log axes, they look like straight lines. The slope of the number density is approximately -2, the slope of the biomass density is approximately -1.\n6) When we work with a logarithmic weight axis, then it is natural to use densities in log weight, where the numbers of individuals in each bin are divided by the width of the bin on the log axis. We refer to these as the number density in log weight or the biomass density in log weight respectively. The slope of the number density in log weight is approximately -1 and the slope of the biomass density in log weight is approximately 0, i.e., the biomass density in log weight is approximately constant. The latter is called the Sheldon spectrum.\n7) The value reported for size-spectrum exponent depends strongly on the methodology used to obtain it. You need to be aware of this when comparing exponents from different papers.\n8) Unlike the community spectrum, the individual species size spectra are not approximately power laws and thus do not look like straight lines on log-log axes. The approximate power law only emerges when we add all the species spectra together."
  },
  {
    "objectID": "understand/observed-size-spectra.html#introduction",
    "href": "understand/observed-size-spectra.html#introduction",
    "title": "Observed size spectra",
    "section": "Introduction",
    "text": "Introduction\nWe will start the introduction into size spectra using text from Ken H Andersen’s book “Fish Ecology, Evolution, and Exploitation” (2019):\n\nWhat is the abundance of organisms in the ocean as a function of body size? If you take a representative sample of all life in the ocean and organize it according to the logarithm of body size, a remarkable pattern appears: the total biomass of all species is almost the same in each size group. The sample of marine life does not have to be very large for the pattern to appear. … What is even more surprising is that the pattern extends beyond the microbial community sampled by plankton nets—it persists up to the largest fish, and even to large marine mammals.\n\n\nThis regular pattern is often referred to as the Sheldon spectrum in deference to R. W. Sheldon, who first described it in a ground-breaking series of publications. Sheldon had gotten hold of an early Coulter counter that quickly and efficiently measured the size of microscopic particles in water. Applying the Coulter counter to microbial life in samples of coastal sea water, he observed that the biomass was roughly independent of cell size among these small organisms (Sheldon and Parsons, 1967). And he saw the pattern repeated again and again when he applied the technique to samples from around the world’s oceans. Mulling over this result for a few years, he came up with a bold conjecture (Sheldon et al., 1972): the pattern exists not only among microbial aquatic life, but it also extends all the way from bacteria to whales.\n\nYou can read more about this work in the references below:\nSheldon, R. W., and T. R. Parsons (1967). “A Continuous Size Spectrum for Particulate Matter in the Sea.” Journal Fisheris Research Board of Canada 24(5): 909–915.\nSheldon, R.W., A. Prakash, andW. H. Sutcliffe (1972). “The Size Distribution of Particles in the Ocean.” Limnology and Oceanography 17(3): 327–340\nBlanchard, J. L., Heneghan, R. F., Everett, J. D., Trebilco, R., & Richardson, A. J. (2017). From bacteria to whales: using functional size spectra to model marine ecosystems. Trends in ecology & evolution, 32(3), 174-186.\nK.H. Andersen, N.S. Jacobsen and K.D. Farnsworth (2016): The theoretical foundations for size spectrum models of fish communities. Canadian Journal of Fisheries and Aquatic Science 73(4): 575-588.\nK.H. Andersen (2019): Fish Ecology, Evolution, and Exploitation - a New Theoretical Synthesis. Princeton University Press.\nAnd in many other references listed in the sizespectrum.org publications page."
  },
  {
    "objectID": "understand/observed-size-spectra.html#example-code",
    "href": "understand/observed-size-spectra.html#example-code",
    "title": "Observed size spectra",
    "section": "Example code",
    "text": "Example code\nThese tutorials contain a lot of working R code, because learning R coding for mizer is best done by looking at example code. The best way of working through these tutorials is to copy over the code you meet in the tutorial over to an R script or R notebook file and then to execute it from there. Initially that will just reproduce the results you see in the tutorial, but after a while we hope that you will start experimenting with making modifications to the code. This is further encouraged by the exercises that you will find dotted throughout the tutorials. Those exercises will encourage you to use code from earlier in the tutorial and to adapt it to the exercise task.\nTo analyse and plot the data we will be making use of the tidyverse package, in particular dplyr and ggplot2. If you are not familiar with these, you can learn what is needed just by studying the example code in this tutorial. Before we can use a package we need to load it in from the package library with the library() function:\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.4.4     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\n\n\n\n\n\n\nNote\n\n\n\nWhen you hover over any function name in the R code in these tutorials, you will notice that they are links. If you click on them this will open the function’s help page in a new browser window. Thus you can always easily read more information about the functions we are using.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nYou will find explanations of the code if you expand the “R details” sections located below many of the code chunks. In order not to annoy the R experts among you, these sections are collapsed initially. To expand an explanation section, just click on the “Expand for R details”.\n\n\n\n\n\n\n\n\nExpand for R details\n\n\n\n\n\nThe library() function loads the named package from your package library. The tidyverse package should already be in your library if you have run the command given on the Install tools page:\n\ninstall.packages(c(\"mizer\", \"tidyverse\", \"plotly\", \"remotes\", \"usethis\",\n                   \"rmarkdown\", \"rstudioapi\"))\n\nThe message that the library(tidyverse) command displays is showing you that it has loaded several other packages that together make up the tidyverse. It also warns you that the “dplyr” package overwrites two functions that already existed in the “stats” package, which is no problem for us."
  },
  {
    "objectID": "understand/observed-size-spectra.html#the-data",
    "href": "understand/observed-size-spectra.html#the-data",
    "title": "Observed size spectra",
    "section": "The data",
    "text": "The data\nSo let’s see if we can find Sheldon’s pattern ourselves. First we download the data from the internet.\n\ndownload.file(\"https://github.com/gustavdelius/mizerCourseNew/raw/master/understand/size-data.rds\",\n              destfile = \"size-data.rds\")\n\nThen we load it into our R session.\n\nsize_data &lt;- readRDS(\"size-data.rds\")\nstr(size_data)\n\n'data.frame':   925594 obs. of  3 variables:\n $ species: chr  \"Cod\" \"Cod\" \"Cod\" \"Cod\" ...\n $ weight : num  52.77 56.37 6.14 5.66 5.89 ...\n $ length : num  17.41 17.8 8.5 8.27 8.38 ...\n\n\n\n\n\n\n\n\nExpand for R details\n\n\n\n\n\nThe code is mostly self-explanatory. The download.file() function fetches the file from the given URL and saves it in a file “size-data.rds” in your current working directory. The readRDS() function then loads the file, which contains the data frame with the size data. We assign this data frame to the variable size_data for use below. Note that the assignment operator in R is &lt;- rather than = as in some other programming languages. To get an impression of what is in the data frame, we use the str() function that generally displays a summary of the structure of an R object.\n\n\n\nThe data consists of measurements of the length in centimetres of 925594 fish of various species. The species included are\n\nunique(size_data$species)\n\n[1] \"Cod\"       \"Whiting\"   \"Haddock\"   \"Saithe\"    \"Herring\"   \"Sandeel\"  \n[7] \"Nor. pout\" \"Plaice\"    \"Sole\"     \n\n\nThis data was assembled by Ken Andersen at DTU Aqua in Copenhagen. The length in centimetres was converted to weight in grams using the standard allometric relationship\n \\mathrm{weight} = a\\, \\mathrm{length} ^ b,\nwhere the coefficient a and the exponent b are species-specific parameters (we’ll discuss how to find such species parameters in a later tutorial).\nThe reason we like to work with weight as the measure of a fish’s size is that there are well-known allometric relationships between weight w and physiological rates. For example, metabolic rate is generally expected to scale as w^{3/4} and mortality to scale as w^{-1/4}, as we will be discussing in the section on allometric rates in the next tutorial.\n\n\n\n\n\n\nNote\n\n\n\nWhen not otherwise specified, all lengths are given in centimetres [cm] and all weights are given in grams [g]."
  },
  {
    "objectID": "understand/observed-size-spectra.html#histogram",
    "href": "understand/observed-size-spectra.html#histogram",
    "title": "Observed size spectra",
    "section": "Histogram",
    "text": "Histogram\nTo get an impression of the size distribution of the fish, we plot a histogram of the fish weights.\n\np &lt;- ggplot(size_data) +\n    geom_histogram(aes(weight), fill = \"blue\", colour = \"black\") +\n    labs(x = \"Weight [g]\",\n         y = \"Number of fish\")\np\n\n\n\n\n\n\n\n\n\n\nExpand for R details\n\n\n\n\n\nWe have used the ggplot2 package, included in the tidyverse package, to make the plot. It is much more powerful and convenient than the base plot commands. It implements the “grammar of graphics”. If you are not already using ggplot2 it is worth your time to familiarise yourself with it. However for the purpose of this tutorial, you can simply pick up the syntax from the examples we give.\nIn the above we first specify with ggplot(size_data) that the graph shall be based on the data frame size_data that we loaded previously. We then add features to the graph with the +.\nFirst geom_histogram() specifies that we want a histogram plot. The argument specifies the variable to be represented. Note how this is wrapped in a call to aes(). Don’t ask why, that is the way the grammar of graphics likes it. The specification of how the variables are tied to the aesthetics of the graph will always be given withing the aes() function.\nWe then specify that we want the bars in the histogram to be blue (fill = \"blue\") with a black border (colour = \"black\"). Such tuning of the appearance is of course totally optional. By the way: one has to admire how the ggplot2 package accepts both colour and color, so that our US friends can use color = \"black\".\nThen we add our own labels to the axes with labs().\nWe assign the resulting plot to the variable p because that way we can manipulate the plot further below. Because the assignment operator in R does not display any result, we added another line with just the variable name p which will display the plot.\n\n\n\nThe plot is not very informative. It just tells us that most fish are very small but there is a small number of very large fish. We can not see much detail. We will apply three methods to improve the graph.\nLogarithmic y axis\nThe first way to improve the plot is to plot the y-axis on a logarithmic scale. That has the effect of stretching out the small values and squashing the large values, revealing more detail.\n\np + scale_y_log10()\n\nWarning: Transformation introduced infinite values in continuous y-axis\n\n\nWarning: Removed 2 rows containing missing values (`geom_bar()`).\n\n\n\n\n\n\n\n\n\n\n\nExpand for R details\n\n\n\n\n\nWe get a warning because there were bins that contained no fish, and taking the log of 0 is not allowed. We can ignore these warnings because the empty bins will simply not be given a bar in the resulting plot.\nUnfortunately by default R uses the engineering notation where for example 1e+03 stands for 1000 or 10^3. You can change that by changing scale_y_log10() to scale_y_log10(labels = scales::comma). Try that to see if you prefer it.\nNote that the y axis still gives the number of fish, not the logarithm of the number of fish. We have only changed the scale on the axis. We have not changed which variable we are plotting.\n\n\n\nLogarithmically sized bins\nThe second way to deal with the fact that there are so many more small fish than large fish, is to make the bin widths different. At the moment all bins are the same width, but we can make bin widths larger at larger sizes and smaller at smaller sizes. For example we could make the smallest bin go from 1 gram to 2 gram, the next bin to go from 2 gram to 4 gram, and so on, with each next bin twice the size of the previous. This means that for large fish, bins will be very wide and thus more individuals will fall into these bins. So let’s create the break points between these bins:\n\nlog_breaks &lt;- seq(from = 0, to = 11, by = 1)\nlog_breaks\n\n [1]  0  1  2  3  4  5  6  7  8  9 10 11\n\nbin_breaks &lt;- 2 ^ log_breaks\nbin_breaks\n\n [1]    1    2    4    8   16   32   64  128  256  512 1024 2048\n\n\n\n\n\n\n\n\nExpand for R details\n\n\n\n\n\nWe had decided that we wanted the breaks between the bins to be located at powers of 2. We first create the vector log_breaks with the exponents. The seq() function creates a vector of numbers starting at from and going up to to in steps of size by. You do not need to give the names of the arguments because they can also be identified by their position. So you could also have written seq(0, 11, 1). Such integer sequences are used so often that there is the even shorter notation 0:11 giving the same sequence.\nThe second line above creates a vector containing the powers of 2 with the exponents we just created in the vector log_breaks. Note how R can perform calculations for all entries of a vector at once, without the need for a loop.\n\n\n\nNow we use these logarithmically-spaced bins in the histogram while also keeping the logarithmic y-axis:\n\np2 &lt;- ggplot(size_data) +\n    geom_histogram(aes(weight), fill = \"blue\", colour = \"black\",\n                   breaks = bin_breaks) +\n    labs(x = \"Weight [g]\",\n         y = \"Number of fish\") +\n    scale_y_log10()\np2\n\n\n\n\nThe heights are now slightly more even among the bins, because the largest bin is so wide.\nIt is very important that you break up your reading of the tutorials with some hands-on work that builds on what you have just learned. Therefore you will find exercises throughout the tutorials. You have now reached the first exercise. You will find that it can be accomplished using the R functions you have already learned about. If you have been running the code from this tutorial in your own R session then you are well set up for doing the exercise.\n\n\n\n\n\n\nExercise 1\n\n\n\n\n\nNow you want to double the number of logarithmically-sized bins used, in order to get a more detailed picture of the size spectrum. So instead of using 11 bins to cover the range from 1g to 2048g, where each bin is twice as large as the previous, you want to use 22 bins to cover the same size range, where each bin is larger than the previous one by a factor of \\sqrt{2}.\nCreate the vector with the breaks between the bins and then use that when you plot the histogram. From this new histogram, please read off the height of the bar at 2kg and compare it to what the earlier histogram in the tutorial showed.\n\n\n\n\n\n\nImportant\n\n\n\nTo do the exercise, you can copy and paste code from earlier, but avoid assigning new values to any of the variables that we have already created in this tutorial, because we might use them later on and if you change them you may find it more difficult to reproduce the rest of the tutorial. Simply choose new variable names in your solution. So for example for the vector with the 22 bin breaks, you could introduce a new variable bin_breaks_22 instead of re-using our bin_breaks. And for the plot instead of our p2 you could use any other name, for example histogram_22.\n\n\n\n\n\n\n\n\nGive me hints\n\n\n\n\n\nTo create the bin breaks you can adapt the code from above, just modifying it so that there are 23 break points for the 22 bins and that they differ by a factor of 2^{1/2} rather than a factor of 2.\nThen you can use the earlier code for producing the histogram, only replacing bin_breaks by bin_breaks_22.\n\n\n\n\n\n\n\n\n\nShow me the solution\n\n\n\n\n\nWe assume that you have run all the earlier code in the tutorial without problems. Then the following new code will produce the desired plot.\n\nlog_breaks_22 &lt;- seq(from = 0, to = 11, by = 1/2)\nlog_breaks_22\n\n [1]  0.0  0.5  1.0  1.5  2.0  2.5  3.0  3.5  4.0  4.5  5.0  5.5  6.0  6.5  7.0\n[16]  7.5  8.0  8.5  9.0  9.5 10.0 10.5 11.0\n\n\n\nbin_breaks_22 &lt;- 2 ^ log_breaks_22\nbin_breaks_22\n\n [1]    1.000000    1.414214    2.000000    2.828427    4.000000    5.656854\n [7]    8.000000   11.313708   16.000000   22.627417   32.000000   45.254834\n[13]   64.000000   90.509668  128.000000  181.019336  256.000000  362.038672\n[19]  512.000000  724.077344 1024.000000 1448.154688 2048.000000\n\n\n\nhistogram_22 &lt;- ggplot(size_data) +\n     geom_histogram(aes(weight), fill = \"blue\", colour = \"black\",\n                    breaks = bin_breaks_22) +\n     labs(x = \"Weight [g]\",\n          y = \"Number of fish\") +\n     scale_y_log10()\nhistogram_22\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nIf you compare your new histogram from the exercise with the one in the tutorial above, you will see that not only do you have more bins but also the height of each bar is smaller than previously. So the height of the bars in a histogram depend on our arbitrary choice of the bin width. We will fix that when we switch to plotting densities instead of histograms below.\n\n\nLogarithmic w axis\nThe third thing we can do to get a better-looking plot is to also display the weight axis on a logarithmic scale:\n\np2 + scale_x_log10()\n\n\n\n\nNote how on the logarithmically-scaled x-axis the logarithmically-sized bins all have the same width."
  },
  {
    "objectID": "understand/observed-size-spectra.html#density-in-size",
    "href": "understand/observed-size-spectra.html#density-in-size",
    "title": "Observed size spectra",
    "section": "Density in size",
    "text": "Density in size\nWe noticed that the height of the bars changed as we changed how we bin the data. That is obvious. If we make a bin twice as large, we expect twice as many fish in that bin. We now want to get rid of this dependence on the choice of the bin width. We can do this if we divide the height of each bar by its width.\nThis idea is familiar to you in a different context. Assume you want to describe the spatial distribution of individuals. You would then divide your area into small squares and count the number of individuals in each of these squares. Then you divide the number of individuals in each square by the area of that square to obtain the average density of individuals in that square. That is a density in space. The only difference now is that instead of dividing space into squares we have divided the size axis into intervals (which we call bins) and to obtain the average density in size we divide the numbers by the lengths of the intervals.\nIn fact, thinking of the weight axis in a similar way to how you think about space will generally be helpful when thinking about size-spectrum modelling, especially if you are already familiar with spatially-resolved models.\nBecause it is important to understand this concept of density in size, we will calculate the number density by hand below, even though ggplot has a built-in function geom_density() that we could use instead. We first bin the data by hand, and then we calculate and plot the densities."
  },
  {
    "objectID": "understand/observed-size-spectra.html#binning",
    "href": "understand/observed-size-spectra.html#binning",
    "title": "Observed size spectra",
    "section": "Binning",
    "text": "Binning\nTo understand better what the histogram did and to improve the plots further, we bin the data ourselves. We do this by first adding a bin number to each observation, which indicates in which bin the weight of the fish lies.\n\ndata_with_bins &lt;- size_data |&gt;\n    mutate(bin = cut(weight, breaks = bin_breaks, right = FALSE,\n                     labels = FALSE))\nhead(data_with_bins)\n\n\n\n  \n\n\n\n\n\n\n\n\n\nExpand for R details\n\n\n\n\n\nWe used the pipe operator |&gt; that simply pipes the output of the code preceeding it into the first argument of the function following it. So the above code is equivalent to\n\ndata_with_bins &lt;- mutate(size_data, bin = cut(weight, breaks = bin_breaks, \n                                         right = FALSE, labels = FALSE))\n\nThe pipe operator becomes really useful only if you do a longer sequence of operations on data. You will see examples of its use later.\nThe mutate() function can add new columns to a data frame or modify existing columns. In the above example it adds a new column bin. The entries in that column are here calculated by the function cut that returns the label of the bin into which an observation falls. We specify the bin boundaries with the breaks = bin_breaks to be the boundaries we have calculated above. The right = FALSE means that in case an observation falls exactly on a right bin boundary, it is not included in that bin but instead in the next bin. The labels = FALSE means that the bins are not labelled by the intervals but simply by integer codes.\n\n\n\nWe then group the data by bin and calculate the number of fish in each bin.\n\nbinned_numbers &lt;- data_with_bins |&gt; \n    group_by(bin) |&gt; \n    summarise(Number = n())\nbinned_numbers\n\n\n\n  \n\n\n\n\n\n\n\n\n\nExpand for R details\n\n\n\n\n\nAfter we have grouped together all the observations with the same bin number with the group_by(bin), the summarize() function creates a new data frame with one row for each group, which in this case means one row for each bin. That data frame will always have one column specifying the group and then we specified that we want an extra column Number that just counts the number of observations in the group with the n() function. Note that the species is ignored in this calculation.\nIn the above code you see the pipe operator |&gt; being quite convenient, because it allows us to write the functions in the order in which they are applied, rather than having to write summarize(group_by(...)).\n\n\n\nThe numbers in each bin give us the heights of the bars in the histogram above."
  },
  {
    "objectID": "understand/observed-size-spectra.html#number-density",
    "href": "understand/observed-size-spectra.html#number-density",
    "title": "Observed size spectra",
    "section": "Number density",
    "text": "Number density\nThe values for Number of course depend on the size of the bins we have chosen. Wider bins will have more fish in them. We now divide these numbers by the bin widths to get the average number density in the bins.\n\nbinned_numbers &lt;- binned_numbers |&gt; \n    mutate(bin_start = bin_breaks[-length(bin_breaks)],\n           bin_end = bin_breaks[-1],\n           bin_width = bin_end - bin_start,\n           Number_density = Number / bin_width)\nbinned_numbers\n\n\n\n  \n\n\n\n\n\n\n\n\n\nExpand for R details\n\n\n\n\n\nHere we are using the mutate() function to add four columns to our binned_numbers data frame. bin_start and bin_end hold the start and end point of each bin and bin_width holds its width. Then when we calculate the entries for the Number_density column by dividing the Number column by the bin_width column.\nThe vector of the start points of the 11 bins is given by the first 11 entries of bin_breaks. We need to exclude the last entry in bin_breaks because that is the end of the last bin and not the start of another bin. this is what bin_breaks[-length(bin_breaks)] does. Note how the - notation allows one to exclude entries from a vector. Similarly we obtain the bin_ends by excluding the first entry of bin_breaks.\n\n\n\nLet’s make a plot of the number density against weight. Note that we only calculated the average number density within each bin. When we make our plot we want to plot this average value at the midpoint of the bin on the logarithmic axis. In between these values the plot then interpolates by straight lines to produce a continuous curve.\n\nbinned_numbers &lt;- binned_numbers |&gt;\n    mutate(bin_midpoint = exp((log(bin_start) + log(bin_end)) / 2))\n\np_number_density &lt;- ggplot(binned_numbers) +\n    geom_line(aes(x = bin_midpoint, y = Number_density)) +\n    labs(x = \"Weight [g]\", y = \"Number density [1/g]\")\np_number_density\n\n\n\n\n\n\n\n\n\n\nExpand for R details\n\n\n\n\n\nYou will by now already be able to read this code. The only subtle bit is that to calculate the midpoint on the logarithmic axis we first need to take the log, then the average and then exponentiate again.\n\n\n\nAgain the graph tells us that most of the individuals are very small, but we can not see any of the details. We therefore plot the density on log-log axes:\n\np_number_density + \n    scale_x_log10() + \n    scale_y_log10()\n\n\n\n\nIt is time for your second exercise of the course.\n\n\n\n\n\n\nExercise 2\n\n\n\n\n\nEarlier you increased the number of bins from 11 to 22. Because the same number of observed fish was then spread over this larger number of bins, all the bars in the histogram were accordingly less high. By going to the number density we have corrected for this. The density plot created with the 22 bins will of course not look exactly the same as the one created with 11 bins. It will look more ragged because it exposes the noise in the data more.\nCreate the plot of the number density using the 22 logarithmically sized bins from exercise 1.\n\n\n\n\n\n\nGive me hints\n\n\n\n\n\nFirst create a new data frame data_with_bins_22 where you assign one of your 22 bins to each observation. You can use the same code as for data_with_bins but using your own bin_breaks_22 vector.\n\ndata_with_bins_22 &lt;- 'copy, paste and adopt code from above'\n\nThen use that data frame to create a new data frame binned_numbers_22 with similar code as above. Keep the same column names in that new data frame as we used in binned_numbers.\n\nbinned_numbers_22 &lt;- 'copy, paste and adopt code from above'\n\nYou can then use the same code for plotting the graph that we used above, just using your new data frame. If you used the same column names in your data frame then the change you need to make to the plotting code is minimal.\n\np_number_density_22 &lt;- 'copy, paste and adapt code from above'\n\n\n\n\n\n\n\n\n\n\nShow me the solution\n\n\n\n\n\n\ndata_with_bins_22 &lt;- size_data |&gt;\n    mutate(bin = cut(weight, breaks = bin_breaks_22, right = FALSE,\n                     labels = FALSE))\n\nNote how we only needed to change the breaks argument to cut().\n\nbinned_numbers_22 &lt;- data_with_bins_22 |&gt; \n    group_by(bin) |&gt; \n    summarise(Number = n()) |&gt;\n    mutate(bin_start = bin_breaks_22[-length(bin_breaks_22)],\n           bin_end = bin_breaks_22[-1],\n           bin_width = bin_end - bin_start,\n           bin_midpoint = exp((log(bin_start) + log(bin_end)) / 2),\n           Number_density = Number / bin_width)\n\nIn the above we just needed to change the dataset we are using and the bin breaks.\n\np_number_density_22 &lt;- ggplot(binned_numbers_22) +\n    geom_line(aes(x = bin_midpoint, y = Number_density)) +\n    labs(x = \"Weight [g]\", y = \"Number density\") +\n    scale_x_log10() + \n    scale_y_log10()\np_number_density_22\n\n\n\n\nNote how the plotting code is the same except that we specified that it should use our new dataframe binned_numbers_22."
  },
  {
    "objectID": "understand/observed-size-spectra.html#fitting-a-power-law",
    "href": "understand/observed-size-spectra.html#fitting-a-power-law",
    "title": "Observed size spectra",
    "section": "Fitting a power law",
    "text": "Fitting a power law\nThe number density in the above log-log plot is described approximately by a straight line. We can approximate the slope and intercept of that straight line by fitting a linear model\n\nmodel &lt;- lm(log(Number_density) ~ log(bin_midpoint), data = binned_numbers)\nmodel\n\n\nCall:\nlm(formula = log(Number_density) ~ log(bin_midpoint), data = binned_numbers)\n\nCoefficients:\n      (Intercept)  log(bin_midpoint)  \n           14.563             -2.241  \n\n\nThis tells us that the straight-line approximation has a slope of about -2.24. We can also ask ggplot to put this line into the plot, together with its 95% confidence interval:\n\nggplot(binned_numbers, aes(x = bin_midpoint, y = Number_density)) +\n    geom_line() + \n    scale_x_log10(name = \"Weight [g]\") + \n    scale_y_log10(name = \"Number density [1/g]\") +\n    geom_smooth(method = 'lm')\n\n\n\n\n\n\n\n\n\n\nExpand for R details\n\n\n\n\n\nThe linear regression line is produced by geom_smooth(method='lm'). Note how we moved the call to aes() into the call to ggplot(). That is then used automatically for both the geom_line() and the geom_smooth(), so that we did not have to specify the information twice.\nWe also have put the text for the axis labels into the calls to scale_x_log10() and scale_y_log10() instead of putting it into a separate labs() function as we have done so far. The two are identical. As always in R, there are many different ways to achieve the same outcome.\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nA straight line on a log-log plot indicates a power-law relationship between the variables with the slope of the line being the exponent in the power law.\n\n\nIf we denote the number density at weight w by N(w), then the above tells us that \\log(N(w)) \\approx 14.6 -2.24 \\log(w).\nIf we exponentiate both sides to get rid of the logarithms this gives\n\nN(w) \\approx \\exp(14.6) w^{-2.24} = N(1) w^{-\\lambda}\n\nwith \\lambda \\approx 2.24.\nThe greek letter lambda or \\lambda is widely used in size spectrum literature and it denotes the size spectrum slope. A steeper slope (larger \\lambda value) means that there are relatively fewer large fish compared to small fish. A more shallow slope (smaller \\lambda) indicates a relatively larger number of large fish. Now you know how these slopes are calculated.\nOf course the approach we took above of estimating the exponent in the power law from the binned data is not ideal. If one has access to unbinned data, as we have here, one should always use that unbinned data. So the better way to estimate the slope or exponent from our data would be to ask: “If we view our set of observed fish sizes as a random sample from the population described by the power law, for which exponent would our observations be the most likely”. In other words, we should do a maximum likelihood estimation of the exponent. We’ll skip the mathematical details and just tell you the result that the maximum likelihood estimate for the power-law exponent \\lambda is\n\\lambda = 1+\\frac{n}{\\sum_{i=1}^n\\log\\frac{w_i}{w_{min}}},\nwhere n is the number of observed fish, w_i is the weight of the ith fish and w_{min} is the weight of the smallest fish. For our data this gives\n\nn &lt;- nrow(size_data)\nw_min &lt;- min(size_data$weight)\nlambda &lt;- 1 + n / sum(log(size_data$weight / w_min))\nlambda\n\n[1] 1.709584\n\n\nYou can see that this approach, which gives equal weight to each observation rather than giving equal weight to each bin, gives a lower value for \\lambda, namely \\lambda \\approx 1.71 instead of \\lambda \\approx 2.24. This is quite a big difference. But this is still not the end of the story, because we did not take measurement error into account. We assumed that we sampled perfectly. But in reality, small individuals are much easier to miss than large ones, so our data is almost certainly under-reporting the number of small individuals, which leads to a smaller \\lambda or more shallow size spectra. Also, in many ecosystems large fish have been removed by fishing, so we might also be missing them. This would lead to steeper slopes and larger \\lambda.\n\n\n\n\n\n\nImportant\n\n\n\nThe value reported for a community size-spectrum exponent depends strongly on the methodology used to obtain it. You need to be aware of this when comparing exponents from different papers."
  },
  {
    "objectID": "understand/observed-size-spectra.html#biomass-density",
    "href": "understand/observed-size-spectra.html#biomass-density",
    "title": "Observed size spectra",
    "section": "Biomass density",
    "text": "Biomass density\nAbove, we first calculated the number of fish in each weight bin and then divided by the width of each bin to obtain the average number density in each bin. Exactly analogously to that, we can calculate the biomass of all the fish in each weight bin and divide that by the width of each bin to obtain the average biomass density in each bin. So in the code below we will now sum weight and not numbers.\n\nbinned_biomass &lt;- data_with_bins |&gt; \n    group_by(bin) |&gt; \n    summarise(Biomass = sum(weight)) |&gt;\n    mutate(bin_start = bin_breaks[-length(bin_breaks)],\n           bin_end = bin_breaks[-1],\n           bin_width = bin_end - bin_start,\n           bin_midpoint = exp((log(bin_start) + log(bin_end)) / 2),\n           Biomass_density = Biomass / bin_width)\n\nggplot(binned_biomass, aes(x = bin_midpoint, y = Biomass_density)) +\n    geom_line() + \n    scale_x_log10(name = \"Weight [g]\") + \n    scale_y_log10(name = \"Biomass density\") +\n    geom_smooth(method = 'lm')\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nFitting a linear model to the binned biomass density data now gives\n\nlm(log(Biomass_density) ~ log(bin_midpoint), data = binned_biomass)\n\n\nCall:\nlm(formula = log(Biomass_density) ~ log(bin_midpoint), data = binned_biomass)\n\nCoefficients:\n      (Intercept)  log(bin_midpoint)  \n           14.615             -1.265  \n\n\nNote that number density and biomass density have very different slopes, because even though there are lots of small fish, each of them contributes little biomass while the fewer large fish each contribute a large biomass. The slope is -1.265 for the biomass density whereas it was -2.24 for the number density.\nIn formulas, if we denote the biomass density by B(w) then B(w) = w N(w). Therefore if the number density scales with the exponent \\lambda as N(w) \\propto w^{-\\lambda} then the biomass density will scale as B(w)\\propto w^{1-\\lambda}."
  },
  {
    "objectID": "understand/observed-size-spectra.html#densities-in-log-weight",
    "href": "understand/observed-size-spectra.html#densities-in-log-weight",
    "title": "Observed size spectra",
    "section": "Densities in log weight",
    "text": "Densities in log weight\nSo far we found evidence of decreasing biomass densities with size. Yet, the tutorial started with a reference to Sheldon’s observation about equal biomass across sizes. How is this consistent with what we found?\nAbove, we calculated densities by dividing the total number or total biomass in each bin by the width that the bin has on the linear weight (w) axis. Instead, we could divide by the width of the bin on the logarithmic weight axis.\nIf we divide the number of fish in each bin by the width of the size bin in log weight we get what we denote as the number density in log weight. Similarly if we divide the biomass in each bin by the width of the size bin on a logarithmic axis we get the biomass density in log weight, which is the Sheldon density.\nLet us create a new data frame that contains all these densities:\n\nbinned_data &lt;- \n    left_join(binned_numbers, binned_biomass,\n              by = c(\"bin\", \"bin_start\", \"bin_end\", \"bin_width\", \n                     \"bin_midpoint\")) |&gt;\n    mutate(bin_width_log_w = log10(bin_end) - log10(bin_start),\n           Number_density_log_w = Number / bin_width_log_w,\n           Biomass_density_log_w = Biomass / bin_width_log_w)\n\n\n\n\n\n\n\nExpand for R details\n\n\n\n\n\nThe left_join() function combines the columns of the two data frames. The columns listed in the by = argument are those that are common between the two data frames. We end up with a data frame that contains in addition to those common columns also the columns Number, Number_density, Biomass and Biomass_density.\nThen we add three further columns: bin_width_log_w holds the width of each bin on the logarithmic axis. This is then used to calculate Number_density_log_w and Biomass_density_log_w. We use the logarithm to base 10 because that is what ggplot2 and mizer like to use. It does not really matter because using a different base would simply multiply the densities by a constant.\n\n\n\nWe next create a plot that shows all these four densities together.\n\nlong_data &lt;- binned_data |&gt;\n    pivot_longer(cols = contains(\"density\"),\n                 names_to = \"Type\", values_to = \"Density\")\n\nggplot(long_data, aes(x = bin_midpoint, y = Density, colour = Type)) +\n    geom_line() + \n    scale_x_log10(name = \"Weight [g]\") + \n    scale_y_log10(name = \"Density\") +\n    geom_smooth(method = 'lm', se = FALSE)\n\n\n\n\n\n\n\n\n\n\nExpand for R details\n\n\n\n\n\nggplot() needs the data frame in what is called the ‘long’ format where instead of having one column for each density, all the values for the densities are in a single column and the type of the density is noted in a second column. pivot_longer() effects this transformation. The cols = contain(\"density\") identifies the four columns that hold the densities (because these all contain the string \"density\" in their name). The other two arguments choose the names for the two new columns.\nSimply by including colour = Type in the aes() call we tell ggplot() to plot a separate curve for each type of density, to use a different colour for each curve and to add a legend explaining this.\nWe added the se = FALSE argument to geom_smooth() to avoid plotting the confidence bands which would have made the plot too confusing.\n\n\n\nWe see that the number density in log weight has the same slope as the biomass density. The biomass density in log weight has the smallest slope.\nThe different densities have different units. One should be explicit about units when plotting quantities with different units on the same axis because the height (but not the slope) of the curves depends on the units chosen. The units of the densities we plotted are determined by two factors: 1) Biomass is measured in grams whereas Numbers are dimensionless and 2) bin widths are measured in grams whereas bin widths in log weight are dimensionless. The densities, obtained by dividing either Biomass or Numbers by either bin widths or bin widths in log weight, have the following units:\n\n\nN(w) has unit 1/grams,\n\nB(w) and N_{\\log w}(w) are dimensionless,\n\nB_{\\log w}(w) has unit grams.\n\n\n\n\n\n\n\nExercise 3\n\n\n\n\n\nUse the lm() function to determine the slope of the straight-line fit to the biomass density in log weight in this log-log plot.\n\n\n\n\n\n\nGive me hints\n\n\n\n\n\nWe have done something similar in the section on Fitting a power law.\n\n\n\n\n\n\n\n\n\nShow me the solution\n\n\n\n\n\n\nlm(log(Biomass_density_log_w) ~ log(bin_midpoint), data = binned_data)\n\n\nCall:\nlm(formula = log(Biomass_density_log_w) ~ log(bin_midpoint), \n    data = binned_data)\n\nCoefficients:\n      (Intercept)  log(bin_midpoint)  \n          15.4694            -0.2651"
  },
  {
    "objectID": "understand/observed-size-spectra.html#sheldons-observation",
    "href": "understand/observed-size-spectra.html#sheldons-observation",
    "title": "Observed size spectra",
    "section": "Sheldon’s observation",
    "text": "Sheldon’s observation\nAll the four density curves are alternative ways of representing the size spectrum. We introduce the notation N_{\\log w}(w) for the number density in log weight and B_{\\log w}(w) for the biomass density in log weight (Sheldon’s density). We have the following relations among the various densities:\nB_{\\log w}(w) = w\\, B(w) \\propto w\\, N_{\\log}(w) = w^2 N(w).\nSo Sheldon’s observation that B_{\\log w}(w) is approximately constant over a large range of sizes w from bacteria to whales can also be stated in terms of the other densities:\n\nThe slope of the number density is approximately -2.\nThe slope of the biomass density and the number density in log weight is approximately -1.\nThe slope of the biomass density in log weight is approximately 0, i.e., the biomass density in log weight is approximately constant."
  },
  {
    "objectID": "understand/observed-size-spectra.html#size-spectra-of-individual-species",
    "href": "understand/observed-size-spectra.html#size-spectra-of-individual-species",
    "title": "Observed size spectra",
    "section": "Size spectra of individual species",
    "text": "Size spectra of individual species\nSo far we have looked at the community spectrum, where we ignored the species identity of the fish. We will now look at the spectra of the individual species. We’ll plot them all on the same graph and display them with plotly so that you can hover over the resulting graph to see which line corresponds to which species. We also include the community size spectrum in black for comparison. The lines look smoother than earlier because now we use kernel density estimation rather than binning to estimate the densities.\n\np &lt;- ggplot(size_data) +\n    geom_density(aes(weight, stat(count), colour = species), adjust = 4) +\n    geom_density(aes(weight, stat(count)), colour = \"black\", lwd = 1.2, adjust = 4) +\n    scale_x_continuous(trans = \"log10\", name = \"Weight [g]\") +\n    scale_y_continuous(trans = \"log10\", limits = c(1, NA), name = \"Number density in log w\")\n\nplotly::ggplotly(p)\n\n\n\n\n\n\n\n\n\n\n\nExpand for R details\n\n\n\n\n\nBinning the data is useful but is not the only way to approximate the densities. In reality you don’t need to bin the data by hand or bin it at all. One can also use the kernel density estimation method and ggplot2 even has that built in to its geom_density().\nBy default, geom_density() would normalise the density so that the integral under the density curve is 1. We use stat(count) to tell it that we want the number density, so that the integral under the curve is the total number, not normalised to 1.\nThe kernel density method works by placing a small Gaussian (bell curve) at each data point and then adding up all these little Gaussians. The adjust = 4 means that the width of these Gaussians is 4 times wider than geom_density() would choose by default. This leads to a smoother density estimate curve. This plays a similar role as the bin width does in histograms.\nNote how easy it was to ask ggplot to draw a separate line for each species. We only had to add the colour = species to geom_density(). ggplot automatically chose some colours for the species and added a legend to the plot.\nWe have replaced scale_x_log10() by scale_x_continuous(trans = \"log10\") which does exactly the same thing. But the latter form is more flexible, which we used in scale_y_continuous(trans = \"log10\", limits = c(1, NA)) to also specify limits for the y axis. We chose to plot densities above 1 only because at smaller values there is only noise. We did not want to set an upper limit, hence the NA.\nWe then did not display the plot p but instead fed it to plotly::ggplotly(). The ggplotly() function takes a plot created with ggplot and converts it into a plot created with plotly. plotly plots are more interactive. We called the ggplotly() function with plotly::ggplotly() because that way we did not need to load the plotly package first, i.e., we did not need to do library(plotly).\n\n\n\nThere are three messages you should take away from this plot:\n\nDifferent species have very different size spectra.\nThe estimates of the species size spectra are not very reliable because we do not have very good data.\nThe community size spectrum looks more regular than the species size spectra.\n\nWe will discuss species size spectra more in the next tutorial, where we will look at them with the help of the mizer model."
  },
  {
    "objectID": "understand/observed-size-spectra.html#summary-and-recap",
    "href": "understand/observed-size-spectra.html#summary-and-recap",
    "title": "Observed size spectra",
    "section": "Summary and recap",
    "text": "Summary and recap\n1) It is very useful for fisheries policy to know how many fish of different sizes there are. This is what size spectra show.\n2) We can represent size spectra in different ways. One is to bin the data into size classes and plot histograms. The drawback is that the height of the bars in a histogram depend on our choice of bins. A bin from 1 to 2g will have fewer individuals than a bin from 1 to 10g.\n3) To avoid the dependence on bin sizes, we use densities, where the total number of individuals or the total biomass of individuals in each bin is divided by the width of the bin. We refer to these as the number density and the biomass density respectively.\n3) The number density looks very different from the biomass density. There will be a lot of very small individuals, so the number density at small sizes will be large, but each individual weighs little, so their total biomass will not be large.\n5) Community size spectra are approximately power laws. When displayed on log-log axes, they look like straight lines. The slope of the number density is approximately -2, the slope of the biomass density is approximately -1.\n6) When we work with a logarithmic weight axis, then it is natural to use densities in log weight, where the numbers of individuals in each bin are divided by the width of the bin on the log axis. We refer to these as the number density in log weight or the biomass density in log weight respectively. The slope of the number density in log weight is approximately -1 and the slope of the biomass density in log weight is approximately 0, i.e., the biomass density in log weight is approximately constant. The latter is called the Sheldon spectrum.\n7) The value reported for size-spectrum exponent depends strongly on the methodology used to obtain it. You need to be aware of this when comparing exponents from different papers.\n8) Unlike the community spectrum, the individual species size spectra are not approximately power laws and thus do not look like straight lines on log-log axes. The approximate power law only emerges when we add all the species spectra together."
  },
  {
    "objectID": "understand/single-species-spectra.html",
    "href": "understand/single-species-spectra.html",
    "title": "Single species spectra",
    "section": "",
    "text": "At the end of the previous tutorial we plotted single-species size spectra from our dataset and observed that they were a bit of a mess. In this tutorial we will use the mizer model to gain an understanding of what determines the shape of a species size spectrum.\nIn this tutorial you are also going to start using mizer functions. When you want to learn more about any of the functions that we use in the examples, simply click on the function name. This will open the function’s help page in a new browser window.\nFirst, load some required packages with the following commands:\n\nlibrary(mizer)\nlibrary(mizerExperimental)\nlibrary(tidyverse)"
  },
  {
    "objectID": "understand/single-species-spectra.html#introduction",
    "href": "understand/single-species-spectra.html#introduction",
    "title": "Single species spectra",
    "section": "",
    "text": "At the end of the previous tutorial we plotted single-species size spectra from our dataset and observed that they were a bit of a mess. In this tutorial we will use the mizer model to gain an understanding of what determines the shape of a species size spectrum.\nIn this tutorial you are also going to start using mizer functions. When you want to learn more about any of the functions that we use in the examples, simply click on the function name. This will open the function’s help page in a new browser window.\nFirst, load some required packages with the following commands:\n\nlibrary(mizer)\nlibrary(mizerExperimental)\nlibrary(tidyverse)"
  },
  {
    "objectID": "understand/single-species-spectra.html#single-species-model",
    "href": "understand/single-species-spectra.html#single-species-model",
    "title": "Single species spectra",
    "section": "Single-species model",
    "text": "Single-species model\nIn this and the next tutorial we want to keep the size-spectrum aspects of the mizer model separate from the multi-species aspects, so that we do not have to think about too many things at once. So we will explore a model where a single species lives in a non-dynamical background community that we will set to a Sheldon power-law abundance. Only in the fourth tutorial of this week exploring species interactions will we start to consider the interesting multi-species phenomena that arise in mizer models.\nIn this tutorial we will only be interested in the shape of the size spectrum, i.e., in how the total number of individuals is distributed over the different sizes. We are not yet interested in the overall abundance of the species. The overall abundance would be influenced by the total rate of reproduction and recruitment for the species. This in turn would be influenced by the size spectrum, because that determines how many of the individuals are mature. This dynamic feedback will of course become important when we build real-world models in week 2 and use them in week 3. But for now we have enough on our plate without thinking also about this.\nMizer collects all the parameters describing a size-spectrum model into one object of class MizerParams. You do not need to set up this object by hand because there are several wrapper functions in mizer that create the object for you for various types of models, and also many functions for changing specific parameters in a model. We will use the newSingleSpeciesParams() function to set up a model describing a single fish species living in an ecosystem whose community size spectrum is given by a power-law.\nThe newSingleSpeciesParams() function has many arguments that allow you to specify parameters for the fish species as well as for the community, but all these arguments have default values, so we can simply call the function without specifying those arguments. We will only specify the power-law exponent lambda of the background community. Note that in mizer the size spectrum exponent refers to the number density and is therefore expected to be around 2.\n\nparams &lt;- newSingleSpeciesParams(lambda = 2.05)\n\nThe function returns a MizerParams object and we have assigned that to the variable params. We will be explaining more about this model as we go along."
  },
  {
    "objectID": "understand/single-species-spectra.html#steady-state-spectrum",
    "href": "understand/single-species-spectra.html#steady-state-spectrum",
    "title": "Single species spectra",
    "section": "Steady state spectrum",
    "text": "Steady state spectrum\nAs a final simplification in this and the next two tutorials, we will only consider the steady state size spectra. The steady state is the state where in each size class the inflow of individuals through growth exactly balances the outflow of individuals through growth and death. This means that the size spectrum is in equilibrium. The initial size spectrum of the species in the params object that we created with newSingleSpeciesParams() has already been set to the steady state size spectrum.\nWe can plot the size spectrum with the plotSpectra() function.\n\nplotSpectra(params, power = 0)\n\n\n\n\nThe power = 0 argument to the plotSpectra() function specifies that we want to plot the number density, rather than for example the biomass density. We’ll discuss this more below in the section on other representations.\nThe green line represents the number density of the background community, labelled as “Resource” in the plot legend, in which our foreground species finds itself. The green line is a straight line with slope lambda = -2.05. Thus the number density of the background community is proportional to w^{-2.05}. It is important to understand that a power-law curve looks like a straight line when plotted on logarithmic axes and the slope of the line is the exponent in the power law. If this does not sound familiar, please revisit the section in the previous tutorial where we fitted a power-law to the community spectrum.\nThe other line represents the number density of our single species, which by default is just named unimaginatively “Target species”. We see that it is a straight line initially, but then has a bump before declining rapidly at large sizes. We will discuss in a short while what causes that shape.\nRemember what these size spectra plots indicate. They show the number density of individuals as a function of size. The initial slope of the target species’ number density is negative, which vaguely means that there are fewer larger fish than smaller fish. That is of course understandable: lots of fish die while they are growing up, so there tend to be fewer fish in larger size classes.\nIt is now time to do the first exercise of this tutorial.\n\n\n\n\n\n\nExercise 1\n\n\n\n\n\nCreate a MizerParams object describing a single species in a power-law background where the Sheldon exponent is 2.1. Then plot the number density as a function of weight.\n\n\n\n\n\n\nShow me the solution\n\n\n\n\n\n\nparams21 &lt;- newSingleSpeciesParams(lambda = 2.1)\nplot21 &lt;- plotSpectra(params21, power = 0)\nplot21"
  },
  {
    "objectID": "understand/single-species-spectra.html#numbers",
    "href": "understand/single-species-spectra.html#numbers",
    "title": "Single species spectra",
    "section": "Numbers",
    "text": "Numbers\nWhile the plotSpectra() function gives us a plot of the number density, it would be nice if we could get at the actual numerical values. We can access them with the initialN() function. Let us assign this to a variable n:\n\nn &lt;- initialN(params)\n\nAs you can see in the “Environment” pane in RStudio, n is a matrix with 1 row and 101 columns.\n\nThe one row corresponds to the one species. In a multispecies model there would be one row for each species, holding the number density for that species. The 101 columns are for the number densities in each of the 101 size classes. By default mizer uses 100+1 size clases (or size bins), although you can easily change that. In fact, n is a named array, i.e., each row and each column has names. These we can extract with the dimnames() function.\n\ndimnames(n)\n\n$sp\n[1] \"Target species\"\n\n$w\n  [1] \"0.001\"   \"0.00112\" \"0.00126\" \"0.00141\" \"0.00158\" \"0.00178\" \"0.002\"  \n  [8] \"0.00224\" \"0.00251\" \"0.00282\" \"0.00316\" \"0.00355\" \"0.00398\" \"0.00447\"\n [15] \"0.00501\" \"0.00562\" \"0.00631\" \"0.00708\" \"0.00794\" \"0.00891\" \"0.01\"   \n [22] \"0.0112\"  \"0.0126\"  \"0.0141\"  \"0.0158\"  \"0.0178\"  \"0.02\"    \"0.0224\" \n [29] \"0.0251\"  \"0.0282\"  \"0.0316\"  \"0.0355\"  \"0.0398\"  \"0.0447\"  \"0.0501\" \n [36] \"0.0562\"  \"0.0631\"  \"0.0708\"  \"0.0794\"  \"0.0891\"  \"0.1\"     \"0.112\"  \n [43] \"0.126\"   \"0.141\"   \"0.158\"   \"0.178\"   \"0.2\"     \"0.224\"   \"0.251\"  \n [50] \"0.282\"   \"0.316\"   \"0.355\"   \"0.398\"   \"0.447\"   \"0.501\"   \"0.562\"  \n [57] \"0.631\"   \"0.708\"   \"0.794\"   \"0.891\"   \"1\"       \"1.12\"    \"1.26\"   \n [64] \"1.41\"    \"1.58\"    \"1.78\"    \"2\"       \"2.24\"    \"2.51\"    \"2.82\"   \n [71] \"3.16\"    \"3.55\"    \"3.98\"    \"4.47\"    \"5.01\"    \"5.62\"    \"6.31\"   \n [78] \"7.08\"    \"7.94\"    \"8.91\"    \"10\"      \"11.2\"    \"12.6\"    \"14.1\"   \n [85] \"15.8\"    \"17.8\"    \"20\"      \"22.4\"    \"25.1\"    \"28.2\"    \"31.6\"   \n [92] \"35.5\"    \"39.8\"    \"44.7\"    \"50.1\"    \"56.2\"    \"63.1\"    \"70.8\"   \n [99] \"79.4\"    \"89.1\"    \"100\"    \n\n\nThe names of the columns are the weight in grams at the start of each size class. Notice how R displays long vectors by breaking them across many lines and starting each line with a number in brackets. That number is the index of the first value in that row. So for example we see that the 61st size class starts at 1 gram. The number density in the size class between 1 gram and 1.12 grams (the start of the next size class) is\n\nn[1, 61]\n\n[1] 0.0003282314\n\n\nIt is important to realise that this is not the number of fish in the size class, but the average number density in the size class. To get the number of fish we have to multiply the number density by the width of the size class. Those widths can be obtained with the dw() function. So the number of fish in each size class is obtained with\n\nnumbers &lt;- n * dw(params)\n\nThe number of individuals in the size class between 1 gram and 1.12 grams is\n\nnumbers[1, 61]\n\n[1] 4.005029e-05\n\n\nYou may be surprised by the small number if you interpret it as the number of fish between 1 gram and 1.12 gram in the entire ocean. However it looks more reasonable if it is the average number per square meter of sea. For more of a discussion of this issue of working with numbers per area, numbers per volume or numbers for the entire system see https://sizespectrum.org/mizer/reference/setParams.html#units-in-mizer\n\n\n\n\n\n\nExercise 2\n\n\n\n\n\nDetermine the total number of fish in the model with sizes between 10 grams and 20 grams. You can use the sum() function to add together contributions from the various size classes.\n\n\n\n\n\n\nGive me a hint\n\n\n\n\n\nYou have seen above how you can get the numbers in a single size bin. To get the numbers in each of a range of size bins you can use syntax like\n\nnumbers[1, 61:65]\n\n           1         1.12         1.26         1.41         1.58 \n4.005029e-05 3.702779e-05 3.423339e-05 3.164987e-05 2.926133e-05 \n\n\nYou can pass a vector of numbers like this to the sum() function to add the numbers together.\n\n\n\n\n\n\n\n\n\nShow me the solution\n\n\n\n\n\nThe size bins covering the range from 10 to 20 grams are the bins 81 to 86 inclusive.\n\nsum(numbers[1, 81:86])\n\n[1] 4.163148e-05"
  },
  {
    "objectID": "understand/single-species-spectra.html#other-representations",
    "href": "understand/single-species-spectra.html#other-representations",
    "title": "Single species spectra",
    "section": "Other representations",
    "text": "Other representations\nWe have seen in the previous tutorial on observed size spectra that the size spectrum can be represented in various ways. Besides the number density N(w) we introduced the biomass density B(w), the number density in log weight N_{\\log}(w) and the biomass density in log weight B_{\\log}(w). These were related to each other by multiplication by different powers of w:\nB(w) = N_{\\log}(w) = w N(w) \\text{ and } B_{\\log}(w) = w^2 N(w).\nWe can use the power argument of the plotSpectra() function to determine which of these densities to plot. Above we plotted the number density by setting power = 0. Without the power argument (or with power = 1 which is the default) the plotSpectra() function plots the biomass density as a function of weight, which is also the number density as a function of log weight:\n\nplotSpectra(params)\n\n\n\n\nNow the green line representing the biomass density of the background has a slope of -1.05. The initial slope of the species biomass density is also negative, meaning that the biomass density in the species decreases with size.\nWe can also plot the biomass density in log weight, i.e., the Sheldon spectrum, by supplying the argument power = 2 to plotSpectra().\n\nplotSpectra(params, power = 2)\n\n\n\n\nThis now shows an approximately constant background biomass density in log weight (the slope of the green line is -0.05). The biomass density of the species in log size initially increases. So if binned in logarithmically-sized bins the biomass in each bin will initially increase, until it starts decreasing close to the maximum size of the species.\nThis latest plot seems to indicate that most of the biomass of the species is concentrated at larger sizes of around 30 grams, whereas the previous plot seemed to indicate that most of the biomass is at the smallest sizes. So which one is true? Please think about this question, because it really highlights the importance of not confusing biomass density with biomass. Questions about the amount of biomass at a size do not make sense. Instead you have to ask about biomass in a size range.\nSo for example, we might want to consider the prey biomass available to two different predators of our species, one small and one large. Assume that the smaller predator feeds on prey in the size range from 1g to 2g. The other predator, which we assume is 10 times larger, feeds on prey in the size range from 10g to 20g. These feeding intervals have the same width on the logarithmic weight axis. Therefore we should look at the plot of the biomass density in log weight to see that the larger predator has a lot more prey biomass from our species available to it than the smaller one. This is in spite of the fact that the plot of biomass density in weight tells us that the biomass density is lower at 10g than at 1g.\nIt may have been a bit confusing that we displayed the same size spectrum in three different ways. But it is important to be aware of this because in the literature you will see all different conventions being used, so if you see a plot of a size spectrum you always need to ask yourself exactly which density is being shown."
  },
  {
    "objectID": "understand/single-species-spectra.html#biomass",
    "href": "understand/single-species-spectra.html#biomass",
    "title": "Single species spectra",
    "section": "Biomass",
    "text": "Biomass\nAs we did for numbers above, let us also look at how to extract biomasses from the model.\nWe already said above that we can obtain the biomass density in a size class from the number density by multiplying the number density by the weight of the individuals in the size class. To obtain the appropriate weights, we use the function w() that returns the weights at the start of each size class. So we calculate\n\nbiomass_density &lt;- n * w(params)\n\nWe obtain the total biomass in each size class by multiplying the biomass density in each size class by the width of each size class\n\nbiomass &lt;- biomass_density * dw(params)\n\nFor example the biomass of fish between 1 gram and 1.12 grams is\n\nbiomass[61]\n\n[1] 4.005029e-05\n\n\nLet us briefly present yet another way to represent the size distribution. When we talk about size spectra, we always have the representation in terms of densities in mind. You may already be familiar with the concept of a densities from probability theory, where you can describe a probability distribution in terms of its probability density function. But perhaps you also know that there is an alternative description of the probability distribution in terms of the cumulative distribution function. We can similarly describe the size distribution of the biomass by a cumulative biomass distribution function, which gives the total biomass of all sizes up to a specific size.\n\n# Initialise an array with the right dimensions\ncumulative_biomass &lt;- biomass\n# Calculate the cumulative sum of all biomasses in previous bins\ncumulative_biomass[] &lt;- cumsum(biomass)\n# Normalise this so that it is given as a percentage of the total biomass\ncdf &lt;- cumulative_biomass / cumulative_biomass[1, 101] * 100\n# Melt the array to a data frame and then plot\np_biomass_cdf &lt;- ggplot(melt(cdf), aes(x = w, y = value)) +\n    geom_line() + \n    labs(x = \"Weight [g]\",\n         y = \"% of total biomass\")\np_biomass_cdf\n\n\n\n\n\n\n\n\n\n\nExpand for R details\n\n\n\n\n\nMizer likes to work with arrays instead of data frames. Our variables n, biomass, cumulative_biomass and cdf are all arrays. I hope you noticed the magic how R can do calculations with all entries of an array in one go.\nggplot2 on the other hand likes to work with data frames instead of arrays. The function melt() allows us to convert the mizer arrays into data frames suitable for ggplot(). You will see this discussed again later.\n\n\n\nThis plot shows us for example that 50% of the individuals are smaller than 12.5g and only a very small percentage is larger than 75g.\nThe biomass density is the slope of this graph. We can also plot the cumulative biomass distribution function on a logarithmic weight axis:\n\np_biomass_cdf +\n    scale_x_log10()\n\n\n\n\nThis graph contains exactly the same information as the previous graph, just showing more detail at smaller sizes and less detail at larger sizes. We can see for example that about 20% of the total biomass is from individuals smaller than 1g, which was difficult to see in the previous graph. The slope of this graph is the biomass density in log weight."
  },
  {
    "objectID": "understand/single-species-spectra.html#allometric-rates",
    "href": "understand/single-species-spectra.html#allometric-rates",
    "title": "Single species spectra",
    "section": "Allometric rates",
    "text": "Allometric rates\nThe first striking feature of the species size-spectrum, independently of which density you plot, is that for small fish (larvae and juveniles) it is given by a straight line. This is due to the allometric scaling of the physiological rates that our model is assuming and which we will discuss in this section. The other striking feature is the bulge at around maturity size, which we will discuss in the section on the shape of the adult spectrum.\nWe will assume that the metabolic rate, i.e., the rate at which an organism expends energy on its basic metabolic needs, scales as a power of the organism’s body size, and the power is about p = 3/4.\nBecause this energy needs to be supplied by consumption of food, it is natural to assume that also the consumption rate scales allometrically with a power of n = 3/4. When the consumption is greater than the metabolic cost then the excess leads to growth. Hence the growth rate too scales allometrically with power 3/4.\nIn a multi-species mizer model the mortality is an emergent property that depends on the abundance of predators. In this single species model the mortality rate is set to the one that would emerge if all the species in the fixed background community predated with the same ferocity as the target species. This leads to a mortality rate that scale allometrically with a power of n - 1 = 3/4 - 1 = -1/4. This means that the death rate experienced by larger individuals is smaller than that of smaller individuals.\nIt is a result of the mathematics that if the growth and death rates scale allometrically with exponents p and n=1-p respectively, for some metabolic exponent p, that the number density at steady state is also a power law, i.e., a straight line on the log-log plot.\nLet us check that in our model the physiological rates are indeed power laws, at least for the small sizes. We can get the growth rate with the getEGrowth() function. We assign the result to a variable that we name growth_rate.\n\ngrowth_rate &lt;- getEGrowth(params)\n\nYou can again see in the “Environment” pane that this is a matrix with one row for the one species and 101 columns for the 101 size classes. So for example the growth rate at size 1 gram is\n\ngrowth_rate[1, 61]\n\n[1] 4.2\n\n\n(because we had seen that the 61st size class starts at 1 gram). This is the instantaneous per-capita growth rate, measured in grams per year. Note that in mizer all rates are measured in units of 1/year, but for many people daily values are easier to understand. Since growth rate here is an instantaneous rate we can simply divide it by 365 to get a daily rate (although note that mizer does not simulate processes on daily time steps). This gives us a growth rate in grams per day for a 1g sized fish of\n\ngrowth_rate[1, 61] / 365\n\n[1] 0.01150685\n\n\nWe would like to make a log-log plot of the growth rate against size to check that it gives a straight line. We will use ggplot() for that purpose. ggplot() likes to work with data frames instead of named matrices, so we first convert the matrix into a data frame with the melt() function.\n\ngrowth_rate_frame &lt;- melt(growth_rate)\n\nYou can see in the “Environment” pane that the new variable that we called growth_rate_frame is a data frame with 101 observations of 3 variables. The 101 observations correspond to the 101 size classes. The 3 variables have names\n\nnames(growth_rate_frame)\n\n[1] \"sp\"    \"w\"     \"value\"\n\n\nThey are the species sp, the size w, and the value which contains the growth_rate. This data frame we can pass to ggplot().\n\np &lt;- ggplot(growth_rate_frame) +\n    geom_line(aes(x = w, y = value)) +\n    scale_x_log10(name = \"Weight [g]\") +\n    scale_y_log10(name = \"Growth rate [g/year]\")\np\n\n\n\n\nNote how we linked the x axis to the w variable and the y axis to the value variable and specified that both axes should be on a logarithmic scale.\nWe see that at least up to a size of a few grams the line is straight. Let’s isolate the growth rate for those smaller sizes\n\ng_small_fish &lt;- filter(growth_rate_frame, w &lt;= 10)\n\nand fit a linear model\n\nlm(log(g_small_fish$value) ~ log(g_small_fish$w))\n\n\nCall:\nlm(formula = log(g_small_fish$value) ~ log(g_small_fish$w))\n\nCoefficients:\n        (Intercept)  log(g_small_fish$w)  \n              1.435                0.750  \n\n\nThe slope of the line is indeed 0.75 = 3/4. In fact, the above shows that for juveniles \\log(g(w)) \\approx 1.435 + \\frac34 \\log(w) and thus g(w) = g_0\\ w^p \\approx \\exp(1.435)\\  w^{3/4}\\approx 4.2\\  w^{3/4}.\nOf course in a real model, the growth rate would not so exactly follow a power law, because the growth rate would vary depending on food availability, for example. In this example food is the background resource and its abundance is fixed, so food abundance does not vary.\n\n\n\n\n\n\nExercise 3\n\n\n\n\n\nUse the methods you have just seen to make a log-log plot of the mortality rate. You can get the mortality rate with the getMort() function. While adjusting the code to this new task, you need to take into account that the name of the size-dimension of the array returned by getMort() is \"w_prey\" instead of \"w\".\nThen fit a linear model to determine the slope and and intercept and thus the allometric exponent r and the coefficient \\mu_0 for the mortality rate \\mu(w) = \\mu_0 w^r.\n\n\n\n\n\n\nShow me the solution\n\n\n\n\n\n\nmort_rate_frame &lt;- melt(getMort(params))\np &lt;- ggplot(mort_rate_frame) +\n    geom_line(aes(x = w_prey, y = value)) +\n    scale_x_log10(name = \"Weight [g]\") +\n    scale_y_log10(name = \"Mortality rate [1/year]\")\np\n\n\n\n\n\nmm &lt;- lm(log(mort_rate_frame$value) ~ log(mort_rate_frame$w_prey))\nmm\n\n\nCall:\nlm(formula = log(mort_rate_frame$value) ~ log(mort_rate_frame$w_prey))\n\nCoefficients:\n                (Intercept)  log(mort_rate_frame$w_prey)  \n                       1.36                        -0.25  \n\n\nTo get the coefficient \\mu_0 for the mortality rate we need to exponentiate the intercept\n\nm0 &lt;- exp(coef(mm)[[1]])\nm0\n\n[1] 3.896722"
  },
  {
    "objectID": "understand/single-species-spectra.html#slope-of-juvenile-spectrum",
    "href": "understand/single-species-spectra.html#slope-of-juvenile-spectrum",
    "title": "Single species spectra",
    "section": "Slope of juvenile spectrum",
    "text": "Slope of juvenile spectrum\nWe have seen that for juvenile fish the growth rate and the death rate are both power laws with exponents p=3/4 and r=p-1=-1/4 respectively. By solving a differential equation we can derive that the juvenile spectrum also follows a power law: N(w) = N_0\\ w^{-\\mu_0/g_0 - p}.\nI won’t do the maths here with you (and you probably don’t want me to anyway), but we can see that the result makes sense. It tells us that the number density drops off faster with size if the mortality rate coefficient \\mu_0 is higher or if the growth rate coefficient g_0 is smaller, which is what we would expect.\nWe can also check this claim numerically. Let’s look at the spectrum of individuals up to 10 grams. By now we know how to do this. We first convert the number density matrix n into a dataframe and then filter out all observations that do not have w\\leq 10. The resulting data frame we pass to ggplot() and ask it to plot a line on log-log axes.\n\nnf &lt;- melt(n) %&gt;% \n  filter(w &lt;= 10)\n\nggplot(nf) +\n  geom_line(aes(x = w, y = value)) +\n  scale_x_log10(name = \"Weight [g]\") +\n  scale_y_log10(name = \"Number density [1/g]\")\n\n\n\n\nThat confirms what we had seen earlier, that for fish less than 10 grams the number density is a power law. To determine the exponent of the power law we need the slope of that straight line in the log-log plot, and the easiest way to do that is to fit a linear model to the log variables:\n\nlm(log(nf$value) ~ log(nf$w))\n\n\nCall:\nlm(formula = log(nf$value) ~ log(nf$w))\n\nCoefficients:\n(Intercept)    log(nf$w)  \n     -8.022       -1.682  \n\n\nThe linear model fit says that the exponent is -1.682. The mathematics claimed that the exponent should be -\\mu_0 / g_0 - p. We have already observed that g_0 \\approx 4.2 and you have determined \\mu_0 in Exercise 3, so we get\n\n-m0 / g0 - 3/4\n\n[1] -1.6777\n\n\nThat is not quite the result of the linear model fit, but that is the nature of numerical calculations: one gets discretisation errors and rounding errors. Anyway, it is close enough. And it is also amazing how we can calculate expected numbers of fish from basic assumptions and rules. Of course, natural ecosystems never look like that, but if we have theoretical expectations derived from clear assumptions (about growth and mortality rate and food availability), we can start asking questions about which processes in natural ecosystems deviate from these generic assumptions, why this happens and how it should affect the observed size spectra."
  },
  {
    "objectID": "understand/single-species-spectra.html#shape-of-adult-spectrum",
    "href": "understand/single-species-spectra.html#shape-of-adult-spectrum",
    "title": "Single species spectra",
    "section": "Shape of adult spectrum",
    "text": "Shape of adult spectrum\nNow that we understand the shape of the size spectrum for the juvenile fish, let us try to understand the shape of the adult spectrum. Here is the plot of the biomass density again, but with the w axis restricted to weights above 10g:\n\nplotSpectra(params, wlim = c(10, NA))\n\n\n\n\nThe increase of abundance that we see at around the maturity size of our species is due to a drop in growth rate at that size. This in turn is due to the fact that the mature fish invests some of its energy into reproduction instead of growth. So the details of the shape of the adult spectrum will be influenced both by food intake, maintenance and mortality (like in juveniles), but also by how adults split their energy income between growth and reproduction.\nInvestment into reproduction\nLet us look at a plot of the proportion of the available energy that is invested into reproduction as a function of the size. This is the product of the proportion of individuals that are mature (obtained with the function maturity() and the proportion of their energy income that a mature fish invests into reproduction (obtained with the function repro_prop().\n\nreprod_proportion &lt;- maturity(params) * repro_prop(params)\n# Convert the array to a data frame for ggplot\npsi &lt;- melt(reprod_proportion)\n\np &lt;- ggplot(psi) +\n    geom_line(aes(x = w, y = value)) +\n    labs(x = \"Weight [g]\",\n         y = \"Proportion invested into reproduction\")\np\n\n\n\n\nHow was this maturity curve specified? You can find the details in the mizer documentation. There are four species parameters involved:\n\nthe maturity size w_mat at which 50% of the individuals are mature.\nthe size w_mat25 at which 25% of the individuals are mature.\nthe asymptotic size w_max at which an organism invests 100% of its income into reproduction and thus growth is zero.\nan exponent m that determines how the proportion that an individual invests into reproduction scales with its size.\n\nSuch species parameters are contained in a data frame inside the params object that we can access with the species_params() function.\n\nspecies_params(params)\n\n\n\n  \n\n\n\nAs you can see, there are a lot of other species parameters, some of which we will talk about later. For now let’s just select the 4 parameters we are interested in.\n\nselect(species_params(params), w_mat, w_mat25, w_max, m)\n\n\n\n  \n\n\n\nAnd with this knowledge of parameter we can improve the plot for clarity and add a vertical line at 25% and 50% maturation weight\n\nmaturation_weight50 &lt;- species_params(params)$w_mat\nmaturation_weight25 &lt;- species_params(params)$w_mat25\n\np + geom_vline(xintercept = maturation_weight50, lty = 2) +\n    geom_vline(xintercept = maturation_weight25, lty = 2, col = \"grey\")\n\n\n\n\nChange in maturity curve\nLet us investigate what happens when we change the maturity curve. Let’s assume the maturity size is actually 40 grams and the size at which 25% of individuals is mature is 30 grams. Let us change the values in the species_params data frame. But first we make a copy of the params object so that we can keep the old version around unchanged.\n\nparams_changed_maturity &lt;- params\n\nIn this copy we now change the species parameters\n\nspecies_params(params_changed_maturity)$w_mat &lt;- 40\nspecies_params(params_changed_maturity)$w_mat25 &lt;- 30\nselect(species_params(params_changed_maturity), w_mat, w_mat25, w_max, m)\n\n\n\n  \n\n\n\nNow the maturity curve has changed, which we can verify by plotting it\n\npsi_changed_maturity &lt;- melt(maturity(params_changed_maturity) * \n                                 repro_prop(params_changed_maturity))\n\nggplot(psi_changed_maturity) +\n    geom_line(aes(x = w, y = value)) +\n    geom_vline(xintercept = species_params(params_changed_maturity)$w_mat, \n               lty = 2) +\n    geom_vline(xintercept = species_params(params_changed_maturity)$w_mat25, \n               lty = 2, col = \"grey\") + \n    labs(x = \"Weight [g]\",\n         y = \"Proportion invested into reproduction\")\n\n\n\n\nTwo curves in one plot\nAt this point let’s take a little break and learn how to draw two curves in the same graph. How can we see the old maturity curve and the new maturity curve in the same plot? First we add an extra column to each dataframe describing it\n\npsi$type &lt;- \"original\"\npsi_changed_maturity$type &lt;- \"changed\"\n\nThen we bind the two data frames together\n\npsi_combined &lt;- rbind(psi, psi_changed_maturity)\n\nand send that combined data frame first to ggplot(). We also run the plot through plotly::ggplotly() to make it interactive, but that is of course entirely optional.\n\np &lt;- ggplot(psi_combined) +\n    geom_line(aes(x = w, y = value, colour = type)) +\n    labs(x = \"Weight [g]\",\n         y = \"Proportion invested into reproduction\")\nplotly::ggplotly(p)\n\n\n\n\n\nThis change in the maturity curve of course implies a change in the growth rates.\n\n\n\n\n\n\nExercise 4\n\n\n\n\n\nMake a plot showing the growth rates of the original model and of the model with the changed maturity curve.\n\n\n\n\n\n\nShow me the solution\n\n\n\n\n\n\ngrowth_rate_frame$type &lt;- \"original\"\nmodified_growth_frame &lt;- melt(getEGrowth(params_changed_maturity))\nmodified_growth_frame$type &lt;- \"changed\"\ngrowth_combined &lt;- rbind(growth_rate_frame, modified_growth_frame)\np &lt;- ggplot(growth_combined) +\n    geom_line(aes(x = w, y = value, colour = type)) +\n    labs(x = \"Weight [g]\",\n         y = \"Growth rate [g/year]\")\nplotly::ggplotly(p)\n\n\n\n\n\n\n\n\n\n\n\nEffect of changed maturity\nNext let us look at how the change in the maturity parameters and the resulting change in the growth rate affects the steady state spectrum. First we need to calculate the new steady state using the function steadySingleSpecies().\n\nparams_changed_maturity &lt;- steadySingleSpecies(params_changed_maturity)\n\nThen we can use the function plotSpectra2() to plot the old size spectrum and the new size spectrum on the same graph.\n\nplotSpectra2(params, name1 = \"Early maturity\",\n             params_changed_maturity, name2 = \"Late maturity\",\n             power = 2, resource = FALSE, wlim = c(10, NA))\n\n\n\n\nAs expected, the bump happens later due to the larger maturity size and it is less steep, because the maturity curve is less steep. This means that fish do not suddenly start investing most of their energy into reproduction, but still keep growing while they are maturity. Since they are still growing they will be moving from one size class to another and fewer individuals will accumulate in one size class.\nThis was our first investigation of how the shape of a species size spectrum changes as model parameters are changed. We will do much more in this direction in the next tutorial in which we discuss how growth and mortality are determined through predation."
  },
  {
    "objectID": "understand/single-species-spectra.html#summary-and-recap",
    "href": "understand/single-species-spectra.html#summary-and-recap",
    "title": "Single species spectra",
    "section": "Summary and recap",
    "text": "Summary and recap\n1) The steady state is the state where the system has reached an equilibrium in which the rate at which individuals grow into each size class is equal to the rate at which individuals either grow out of the size class or die in the size class.\n2) Mizer stores the size spectrum in the form of the number density in size classes. To get the numbers in a size class we need to multiply the number density by the width of the size class (dw). To get total biomass in each size class we further multiple this value by the weight of this size class (w).\n3) Allometric scaling of physiological rates with size plays a big role in a mizer model and shapes the size spectrum.\n4) We studied a single species living in a fixed background community with a power-law spectrum. In this simple case we can determine the steady state spectrum and find that the juvenile spectrum is given by a power law whose exponent is determined by the ratio of mortality to growth and is different from the community spectrum power law.\n5) As fish mature they start investing some of their energy into reproduction and hence their growth slows. This leads to a bump in the size spectrum. We saw how changes in the parameters describing the maturity ogive change the shape of that bump."
  }
]